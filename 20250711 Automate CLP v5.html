<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Automae Container Loader Planeer by Daniel</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 0;
            min-height: 700px;
        }

        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 1px solid #e9ecef;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .dimensions-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .preset-pallets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px 6px;
            background: #e9ecef;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            font-family: inherit;
            text-align: center;
            line-height: 1.2;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preset-btn:nth-child(5) {
            grid-column: 1 / -1;
            max-width: 50%;
            margin: 0 auto;
        }

        .preset-btn:hover {
            background: #667eea;
            color: white;
        }

        .add-pallet-btn, .calculate-btn, .test-btn, .export-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            font-family: inherit;
        }

        .test-btn {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .export-btn {
             background: linear-gradient(135deg, #5bc0de, #337ab7);
        }


        .add-pallet-btn:hover, .calculate-btn:hover, .test-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .pallet-list {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e9ecef;
        }

        .pallet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
        }

        .pallet-item .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .visualization {
            padding: 30px;
            background: white;
        }

        .container-view {
            background: #2c3e50;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            position: relative;
            overflow: visible;
            min-height: 400px;
        }

        .work-area {
            position: relative;
            width: 100%;
            min-height: 400px;
            overflow: visible;
        }

        .container-floor {
            background: #34495e;
            border: 3px solid #e74c3c;
            border-radius: 8px;
            position: absolute;
            left: 0;
            top: 0;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.3);
            width: 600px;
            height: 300px;
        }

        .container-floor::before {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 1px solid rgba(231, 76, 60, 0.5);
            pointer-events: none;
        }

        .pallet-2d {
            position: absolute;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: 0 0 0 5px rgba(255,255,255,0.1);
            touch-action: none;
            transition: box-shadow 0.2s ease, background 0.2s ease;
        }

        .pallet-2d:hover {
            filter: brightness(1.2);
            z-index: 10;
        }
        
        .pallet-2d.dragging {
            cursor: grabbing;
            z-index: 1000;
            opacity: 0.8;
            box-shadow: 0 0 15px rgba(255,255,255,0.7);
        }
        
        .pallet-2d.colliding {
            box-shadow: 0 0 0 4px rgba(255, 20, 20, 0.8) !important;
        }

        .pallet-2d.outside-container {
            border-color: rgba(231, 76, 60, 0.9) !important;
            box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.6) !important;
            opacity: 0.9;
        }

        .pallet-2d.bottom-placed {
            opacity: 0.9;
            border-color: rgba(108, 117, 125, 0.8);
            box-shadow: 0 0 0 2px rgba(108, 117, 125, 0.4);
        }

        .pallet-2d.deleted {
            opacity: 0.3;
            filter: grayscale(100%);
            pointer-events: none;
        }

        .pallet-label {
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            pointer-events: none;
            text-align: center;
            line-height: 1.2;
            padding: 0 5px;
            box-sizing: border-box;
        }

        .pallet-controls {
            position: absolute;
            top: 2px;
            right: 2px;
            display: flex;
            gap: 2px;
            z-index: 100;
        }

        .rotate-btn, .delete-btn {
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: white;
            cursor: pointer;
            transition: background 0.2s ease;
            pointer-events: auto;
            border: none;
        }

        .rotate-btn:hover {
            background: rgba(0, 100, 200, 0.8);
        }

        .delete-btn:hover {
            background: rgba(220, 53, 69, 0.8);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 18px;
            border-radius: 12px;
            text-align: center;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            opacity: 0.9;
            font-size: 14px;
        }

        .loading-animation {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .success-message {
            background: #d1edff;
            color: #0c5460;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .container-info {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .manual-instructions {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #856404;
        }

        .manual-instructions h4 {
            margin-bottom: 8px;
            color: #856404;
        }

        .manual-instructions ul {
            margin-left: 20px;
        }

        .unloaded-summary {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .unloaded-summary h4 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .unloaded-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 5px;
            background: rgba(255, 193, 7, 0.1);
            border-radius: 4px;
            font-size: 13px;
            color: #856404;
        }
    </style>
</head>
<body>
<div class="container">
<div class="header">
<h1>📦 コンテナ積載プランナー（最適化版）</h1>
<p>パフォーマンス改善とバグ修正を実施した改良バージョン</p>
</div>
<div class="main-content">
<div class="sidebar">
<div class="form-group">
<label for="containerType">コンテナタイプ</label>
<select id="containerType">
<option value="20ft">20ftコンテナ (5.898m × 2.352m 内寸)</option>
<option value="40ft">40ftコンテナ (12.032m × 2.350m 内寸)</option>
</select>
</div>
<div class="form-group">
<label>パレット寸法 (cm)</label>
<div class="dimensions-grid">
<input id="palletLength" max="300" min="1" placeholder="長さ" type="number"/>
<input id="palletWidth" max="300" min="1" placeholder="幅" type="number"/>
</div>
<div class="preset-pallets">
<button class="preset-btn" data-length="120" data-width="100" type="button">
                            EUR<br/>(120×100)
                        </button>
<button class="preset-btn" data-length="120" data-width="80" type="button">
                            EUR2<br/>(120×80)
                        </button>
<button class="preset-btn" data-length="122" data-width="102" type="button">
                            US<br/>(122×102)
                        </button>
<button class="preset-btn" data-length="110" data-width="110" type="button">
                            正方形<br/>(110×110)
                        </button>
<button class="preset-btn" data-length="100" data-width="125" type="button">
                            カスタム<br/>(100×125)
                        </button>
</div>
</div>
<div class="form-group">
<label for="palletQty">数量</label>
<input id="palletQty" max="100" min="1" placeholder="パレット数" type="number" value="1"/>
</div>
<div class="form-group">
<label for="clearanceValue">クリアランス (cm)</label>
<input id="clearanceValue" max="50" min="0" placeholder="クリアランス" step="0.1" type="number" value="0"/>
<small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                        パレット間の最小間隔を設定（0.1cm刻み調整可能）<br/>
<strong>※計算時に適用されます（0=隙間なし配置で最大積載）</strong>
</small>
</div>
<button class="add-pallet-btn" id="addPalletBtn" type="button">➕ パレットタイプを追加</button>
<div class="form-group">
<label>パレットリスト</label>
<div class="pallet-list" id="palletList">
<p style="text-align: center; color: #6c757d; font-style: italic;">パレットがまだ追加されていません</p>
</div>
</div>
<button class="test-btn" id="testBtn" type="button">🧪 テストケース実行</button>
<button class="calculate-btn" id="calculateBtn" type="button">🔄 積載プランを計算</button>
<button class="export-btn" id="exportBtn" style="display: none;" type="button">🖼️ 配置図を画像で保存</button>
</div>
<div class="visualization">
<div class="error-message" id="errorMessage"></div>
<div class="success-message" id="successMessage"></div>
<div class="container-info" id="containerInfo">
                    コンテナタイプを選択してパレットを追加してください
                </div>
<div class="loading-animation" id="loadingAnimation">
<div class="spinner"></div>
<p>最適な積載プランを計算中...</p>
</div>
                <div class="manual-instructions" id="manualInstructions" style="display: none;">
<h4>📋 マニュアル調整ガイド</h4>
<ul>
<li>🖱️ パレットをドラッグして自由に位置調整</li>
<li>↻ 回転ボタンで向きを変更</li>
<li>🗑️ 削除ボタンで不要なパレットを除去</li>
<li>🔴 赤い枠線はコンテナ枠外配置を示します</li>
<li>📦 グレー枠線は下側配置（自動で配置されたもの）</li>
<li>🔄 同じサイズでも個別に向きを変更可能</li>
<li>✨ 境界制限なし：コンテナ枠線ぴったりまで配置可能</li>
</ul>
</div>
<div class="legend" id="legend" style="display: none;">
</div>
<div class="unloaded-summary" id="unloadedSummary" style="display: none;"></div>
<div class="container-view">
<div class="work-area">
<div class="container-floor" id="containerFloor">
</div>
</div>
</div>
<div class="stats" id="stats" style="display: none;">
<div class="stat-card">
<div class="stat-value" id="inputPallets">0</div>
<div class="stat-label">入力パレット数</div>
</div>
<div class="stat-card">
<div class="stat-value" id="visiblePallets">0</div>
<div class="stat-label">表示パレット数</div>
</div>
<div class="stat-card">
<div class="stat-value" id="loadedPallets">0</div>
<div class="stat-label">枠内パレット数</div>
</div>
<div class="stat-card">
<div class="stat-value" id="loadingRate">0%</div>
<div class="stat-label">積載率</div>
</div>
<div class="stat-card">
<div class="stat-value" id="efficiency">0%</div>
<div class="stat-label">床面効率</div>
</div>
<div class="stat-card">
<div class="stat-value" id="remainingArea">0m²</div>
<div class="stat-label">残り床面積</div>
</div>
</div>
</div>
</div>
</div>
<script>
        // 定数の一元管理
        const CONSTANTS = {
            CONTAINER_OFFSET_X: 30,
            CONTAINER_OFFSET_Y: 30,
            CONTAINER_DISPLAY_WIDTH: 800,
            CONTAINER_DISPLAY_HEIGHT: 300,
            MIN_DRAG_MARGIN: 10,
            EPSILON: 0.01,
            ANIMATION_DELAY: 500
        };

        // グローバル変数
        let pallets = [];
        let allPalletsGenerated = [];
        let renderConfig = {
            scale: 1,
            containerOffset: { x: CONSTANTS.CONTAINER_OFFSET_X, y: CONSTANTS.CONTAINER_OFFSET_Y },
            containerBounds: null
        };

        const containers = {
            '20ft': { length: 589.8, width: 235.2 },
            '40ft': { length: 1203.2, width: 235.0 }
        };

        // DOM要素のキャッシュ
        const elements = {
            containerType: document.getElementById('containerType'),
            palletLength: document.getElementById('palletLength'),
            palletWidth: document.getElementById('palletWidth'),
            palletQty: document.getElementById('palletQty'),
            clearanceValue: document.getElementById('clearanceValue'),
            addPalletBtn: document.getElementById('addPalletBtn'),
            calculateBtn: document.getElementById('calculateBtn'),
            testBtn: document.getElementById('testBtn'),
            exportBtn: document.getElementById('exportBtn'),
            palletList: document.getElementById('palletList'),
            containerInfo: document.getElementById('containerInfo'),
            loadingAnimation: document.getElementById('loadingAnimation'),
            manualInstructions: document.getElementById('manualInstructions'),
            legend: document.getElementById('legend'),
            unloadedSummary: document.getElementById('unloadedSummary'),
            containerFloor: document.getElementById('containerFloor'),
            stats: document.getElementById('stats'),
            errorMessage: document.getElementById('errorMessage'),
            successMessage: document.getElementById('successMessage')
        };

        // ユーティリティ関数
        const utils = {
            getCurrentClearance: () => parseFloat(elements.clearanceValue.value) || 0,
            getRandomColor: () => {
                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            showError: (message) => {
                elements.errorMessage.textContent = message;
                elements.errorMessage.style.display = 'block';
                setTimeout(() => elements.errorMessage.style.display = 'none', 5000);
            },
            showSuccess: (message) => {
                elements.successMessage.textContent = message;
                elements.successMessage.style.display = 'block';
                setTimeout(() => elements.successMessage.style.display = 'none', 5000);
            },
            adjustColor: (color, amount) => {
                return '#' + color.replace(/^#/, '').replace(/../g, value => 
                    ('0' + Math.min(255, Math.max(0, parseInt(value, 16) + amount)).toString(16)).substr(-2)
                );
            },
            calculateScale: (container) => {
                const scaleX = CONSTANTS.CONTAINER_DISPLAY_WIDTH / container.length;
                const scaleY = CONSTANTS.CONTAINER_DISPLAY_HEIGHT / container.width;
                return Math.min(scaleX, scaleY);
            }
        };

        // パレット管理
        const palletManager = {
            add: function() {
                const length = parseInt(elements.palletLength.value);
                const width = parseInt(elements.palletWidth.value);
                const qty = parseInt(elements.palletQty.value);
                
                if (!this.validate(length, width, qty)) return;
                
                pallets.push({
                    id: Date.now(),
                    length,
                    width,
                    qty,
                    color: utils.getRandomColor()
                });
                
                updatePalletList();
                updateContainerInfo();
                clearInputs();
                clearResults();
            },
            
            validate: (length, width, qty) => {
                if (!length || !width || !qty || length <= 0 || width <= 0 || qty <= 0) {
                    utils.showError('有効なパレット寸法と数量を入力してください');
                    return false;
                }
                if (length > 300 || width > 300) {
                    utils.showError('パレットサイズは300cm以下にしてください');
                    return false;
                }
                if (qty > 100) {
                    utils.showError('パレット数量は100個以下にしてください');
                    return false;
                }
                return true;
            },
            
            remove: (id) => {
                pallets = pallets.filter(p => p.id !== id);
                updatePalletList();
                updateContainerInfo();
                clearResults();
            }
        };

        // テストケース
        function runTestCase() {
            pallets = [];
            allPalletsGenerated = [];
            elements.containerType.value = '40ft';
            elements.clearanceValue.value = '0';
            
            const testData = [
                { l: 110, w: 110, q: 12, c: '#f39c12' },  // 黄色
                { l: 100, w: 125, q: 8, c: '#3498db' }    // 青色
            ];
            
            testData.forEach((p, i) => pallets.push({
                id: Date.now() + i,
                length: p.l,
                width: p.w,
                qty: p.q,
                color: p.c
            }));
            
            updatePalletList();
            updateContainerInfo();
            clearResults();
            utils.showSuccess('🎯 エリア分割配置テスト: 110×110 (12個) + 100×125 (8個)');
        }

        // UI更新関数
        function updatePalletList() {
            elements.palletList.innerHTML = '';
            
            if (pallets.length === 0) {
                elements.palletList.innerHTML = '<p style="text-align:center;color:#6c757d;font-style:italic;">パレットがありません</p>';
                return;
            }
            
            pallets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'pallet-item';
                item.innerHTML = `<span>${p.length}×${p.width}cm (${p.qty}個)</span><button class="remove-btn">✕</button>`;
                item.querySelector('.remove-btn').addEventListener('click', () => palletManager.remove(p.id));
                elements.palletList.appendChild(item);
            });
        }

        function updateContainerInfo() {
            const container = containers[elements.containerType.value];
            elements.containerInfo.innerHTML = `${elements.containerType.value}内寸: ${(container.length/100).toFixed(3)}m×${(container.width/100).toFixed(3)}m <small>クリアランス: ${utils.getCurrentClearance()}cm</small>`;
        }

        function clearInputs() {
            elements.palletLength.value = '';
            elements.palletWidth.value = '';
            elements.palletQty.value = '1';
        }

        function clearResults() {
            allPalletsGenerated = [];
            const workArea = elements.containerFloor.parentElement;
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // レンダリング設定をリセット
            const container = containers[elements.containerType.value];
            renderConfig.scale = utils.calculateScale(container);
            
            elements.containerFloor.style.width = `${container.length * renderConfig.scale}px`;
            elements.containerFloor.style.height = `${container.width * renderConfig.scale}px`;
            elements.containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            elements.containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            ['stats', 'legend', 'unloadedSummary', 'exportBtn', 'manualInstructions'].forEach(id => {
                elements[id].style.display = 'none';
            });
        }

        // 配置アルゴリズム関連
        function canPlace2D(x, y, length, width, placed, clearance, container = null) {
            const rect1 = { x, y, length, width };
            const cont = container || containers[elements.containerType.value];
            
            // 境界チェック
            if (x < 0 || y < 0 || x + length > cont.length || y + width > cont.width) {
                return false;
            }
            
            // 衝突チェック
            return !placed.some(rect2 => rectanglesOverlapWithClearance(rect1, rect2, clearance));
        }

        function rectanglesOverlapWithClearance(r1, r2, clearance) {
            return !(
                r1.x + r1.length + clearance <= r2.x + CONSTANTS.EPSILON ||
                r2.x + r2.length + clearance <= r1.x + CONSTANTS.EPSILON ||
                r1.y + r1.width + clearance <= r2.y + CONSTANTS.EPSILON ||
                r2.y + r2.width + clearance <= r1.y + CONSTANTS.EPSILON
            );
        }
        function calculateLoading() {
            if (pallets.length === 0) {
                return utils.showError('少なくとも1つのパレットタイプを追加してください');
            }
            
            const container = containers[elements.containerType.value];
            const clearance = utils.getCurrentClearance();
            elements.loadingAnimation.style.display = 'block';
            elements.exportBtn.style.display = 'none';

            setTimeout(() => {
                allPalletsGenerated = [];
                
                // 全パレットを生成
                pallets.forEach(pt => {
                    for (let i = 0; i < pt.qty; i++) {
                        allPalletsGenerated.push({
                            id: pt.id,
                            instance: i,
                            length: pt.length,
                            width: pt.width,
                            color: pt.color,
                            placed: false,
                            deleted: false,
                            x: 0,
                            y: 0,
                            finalLength: pt.length,
                            finalWidth: pt.width,
                            rotated: false
                        });
                    }
                });
                
                console.log(`生成されたパレット数: ${allPalletsGenerated.length}`);
                console.log(`コンテナサイズ: ${container.length}cm × ${container.width}cm`);
                console.log(`クリアランス: ${clearance}cm`);
                
                // 自動配置
                packPallets2D(allPalletsGenerated.filter(p => !p.deleted), container, clearance);
                
                const placedCount = allPalletsGenerated.filter(p => p.placed).length;
                const rotatedCount = allPalletsGenerated.filter(p => p.placed && p.rotated).length;
                
                elements.loadingAnimation.style.display = 'none';
                elements.exportBtn.style.display = 'block';
                elements.manualInstructions.style.display = 'block';
                
                renderAllPallets(container);
                updateStats(container);
                updateLegend();

                if (placedCount === allPalletsGenerated.length) {
                    utils.showSuccess(`🎉 全${allPalletsGenerated.length}個のパレットが自動配置されました！（回転: ${rotatedCount}個）`);
                } else if (placedCount > 0) {
                    utils.showSuccess(`⚡ ${placedCount}/${allPalletsGenerated.length}個を自動配置（回転: ${rotatedCount}個）。残りはマニュアル調整してください。`);
                } else {
                    utils.showSuccess(`📦 ${allPalletsGenerated.length}個のパレットを生成しました。マニュアルで配置してください。`);
                }
            }, CONSTANTS.ANIMATION_DELAY);
        }

        // 簡略化された配置アルゴリズム
        function packPallets2D(palletsToPlace, container, clearance) {
            const placed = [];
            
            // パレットをタイプごとにグループ化
            const groups = {};
            palletsToPlace.forEach(pallet => {
                const key = `${pallet.length}x${pallet.width}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(pallet);
            });
            
            console.log(`グループ数: ${Object.keys(groups).length}`);
            Object.entries(groups).forEach(([key, pallets]) => {
                console.log(`  ${key}: ${pallets.length}個`);
            });
            
            // 100×125パレットの特殊配置パターンを試行
            if (groups['100x125'] && groups['100x125'].length >= 8) {
                const specialPlaced = trySpecialPattern100x125(groups['100x125'], container, clearance);
                if (specialPlaced.length > 0) {
                    console.log(`100×125特殊パターンで ${specialPlaced.length} 個配置成功`);
                    // 配置されたパレットの情報を更新
                    specialPlaced.forEach(p => {
                        const original = allPalletsGenerated.find(pallet => 
                            pallet.id === p.id && pallet.instance === p.instance
                        );
                        if (original) {
                            original.placed = true;
                            original.x = p.x;
                            original.y = p.y;
                            original.finalLength = p.finalLength;
                            original.finalWidth = p.finalWidth;
                            original.rotated = p.rotated;
                        }
                        placed.push({
                            x: p.x,
                            y: p.y,
                            length: p.finalLength,
                            width: p.finalWidth
                        });
                    });
                }
            }
            
            // 110×110パレットをグリッド配置
            if (groups['110x110']) {
                const gridPlaced = placeGridPattern(groups['110x110'], container, clearance, placed);
                gridPlaced.forEach(p => {
                    const original = allPalletsGenerated.find(pallet => 
                        pallet.id === p.id && pallet.instance === p.instance
                    );
                    if (original) {
                        original.placed = true;
                        original.x = p.x;
                        original.y = p.y;
                        original.finalLength = p.finalLength;
                        original.finalWidth = p.finalWidth;
                        original.rotated = p.rotated;
                    }
                    placed.push({
                        x: p.x,
                        y: p.y,
                        length: p.finalLength,
                        width: p.finalWidth
                    });
                });
            }
            
            // 残りのパレットを通常配置
            const remainingPallets = palletsToPlace.filter(p => !p.placed);
            console.log(`残りパレット数: ${remainingPallets.length}`);
            
            // パレットをサイズでソート（大きいものから）
            remainingPallets.sort((a, b) => (b.length * b.width) - (a.length * a.width));
            
            remainingPallets.forEach(pallet => {
                let bestPosition = null;
                let bestScore = Infinity;
                let bestRotated = false;
                
                // 通常配置と回転配置の両方を試行
                const orientations = pallet.length !== pallet.width ?
                    [[pallet.length, pallet.width, false], [pallet.width, pallet.length, true]] :
                    [[pallet.length, pallet.width, false]];
                
                orientations.forEach(([length, width, rotated]) => {
                    // グリッドベースで配置位置を探索
                    for (let y = 0; y <= container.width - width; y += 5) {
                        for (let x = 0; x <= container.length - length; x += 5) {
                            if (canPlace2D(x, y, length, width, placed, clearance)) {
                                // 左下を優先するスコア計算
                                const score = x + y * 2;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPosition = { x, y };
                                    bestRotated = rotated;
                                }
                            }
                        }
                    }
                });
                
                if (bestPosition) {
                    pallet.placed = true;
                    pallet.x = bestPosition.x;
                    pallet.y = bestPosition.y;
                    pallet.rotated = bestRotated;
                    
                    if (bestRotated) {
                        pallet.finalLength = pallet.width;
                        pallet.finalWidth = pallet.length;
                    } else {
                        pallet.finalLength = pallet.length;
                        pallet.finalWidth = pallet.width;
                    }
                    
                    placed.push({
                        x: pallet.x,
                        y: pallet.y,
                        length: pallet.finalLength,
                        width: pallet.finalWidth
                    });
                }
            });
            
            console.log(`通常配置で追加配置: ${remainingPallets.filter(p => p.placed).length}個`);
            
            // 未配置パレットの整列
            const unplaced = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
            if (unplaced.length > 0) {
                console.log(`未配置パレット: ${unplaced.length}個`);
                let offsetX = 0;
                let offsetY = container.width + 30;
                let currentRowMaxHeight = 0;
                
                unplaced.forEach(pallet => {
                    if (offsetX + pallet.finalLength > container.length) {
                        offsetX = 0;
                        offsetY += currentRowMaxHeight + 10;
                        currentRowMaxHeight = 0;
                    }
                    
                    pallet.x = offsetX;
                    pallet.y = offsetY;
                    
                    currentRowMaxHeight = Math.max(currentRowMaxHeight, pallet.finalWidth);
                    offsetX += pallet.finalLength + 10;
                });
            }
        }
        
        // 100×125パレットの特殊配置パターン
        function trySpecialPattern100x125(pallets, container, clearance) {
            const placedPallets = [];
            const areaPlaced = [];
            
            // 配置パターン定義（横向き=true, 縦向き=false）
            const pattern = [
                // 上段: 横、縦、横、縦
                { row: 0, col: 0, rotated: true },   // 125×100
                { row: 0, col: 1, rotated: false },  // 100×125
                { row: 0, col: 2, rotated: true },   // 125×100
                { row: 0, col: 3, rotated: false },  // 100×125
                // 下段: 縦、横、縦、横
                { row: 1, col: 0, rotated: false },  // 100×125
                { row: 1, col: 1, rotated: true },   // 125×100
                { row: 1, col: 2, rotated: false },  // 100×125
                { row: 1, col: 3, rotated: true }    // 125×100
            ];
            
            let palletIndex = 0;
            const startX = 0;
            const startY = 0;
            
            pattern.forEach((pos, index) => {
                if (palletIndex >= pallets.length) return;
                
                const pallet = pallets[palletIndex];
                let x, y, length, width;
                
                if (pos.row === 0) {
                    // 上段の配置
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 125 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 125 + 100 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 125 + 100 + 125 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY;
                } else {
                    // 下段の配置
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 100 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 100 + 125 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 100 + 125 + 100 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY + 125 + clearance;  // 下段は125cm下（上段の高さは100と125の最大値）
                }
                
                // 配置可能かチェック
                if (x + length <= container.length && y + width <= container.width &&
                    canPlace2D(x, y, length, width, areaPlaced, 0)) {
                    
                    placedPallets.push({
                        ...pallet,
                        x: x,
                        y: y,
                        finalLength: length,
                        finalWidth: width,
                        rotated: pos.rotated,
                        placed: true
                    });
                    
                    areaPlaced.push({
                        x: x,
                        y: y,
                        length: length,
                        width: width
                    });
                    
                    palletIndex++;
                    console.log(`100×125 配置: ${pos.rotated ? '横' : '縦'}向き at (${x}, ${y})`);
                }
            });
            
            return placedPallets;
        }
        
        // グリッドパターン配置（110×110用）
        function placeGridPattern(pallets, container, clearance, alreadyPlaced) {
            const placedPallets = [];
            const length = 110;
            const width = 110;
            
            // 100×125の配置エリアを避けて右側に配置
            const startX = 500 + clearance;  // 100×125エリアの右側
            const startY = 0;
            
            const cols = Math.floor((container.length - startX) / (length + clearance));
            const rows = Math.floor(container.width / (width + clearance));
            
            let palletIndex = 0;
            
            for (let row = 0; row < rows && palletIndex < pallets.length; row++) {
                for (let col = 0; col < cols && palletIndex < pallets.length; col++) {
                    const x = startX + col * (length + clearance);
                    const y = startY + row * (width + clearance);
                    
                    if (canPlace2D(x, y, length, width, alreadyPlaced, clearance)) {
                        const pallet = pallets[palletIndex++];
                        placedPallets.push({
                            ...pallet,
                            x: x,
                            y: y,
                            finalLength: length,
                            finalWidth: width,
                            rotated: false,
                            placed: true
                        });
                    }
                }
            }
            
            console.log(`110×110 グリッド配置: ${cols}列×${rows}行で${placedPallets.length}個配置`);
            
            return placedPallets;
        }
        
        // エリア分割配置戦略
        function tryAreaDivisionPlacement(groups, container, clearance) {
            const placedPallets = [];
            const groupKeys = Object.keys(groups);
            
            if (groupKeys.length !== 2) return placedPallets;
            
            // 2つのグループのパレットサイズを取得
            const group1 = groups[groupKeys[0]];
            const group2 = groups[groupKeys[1]];
            
            console.log(`エリア分割配置: ${groupKeys[0]} (${group1.length}個) と ${groupKeys[1]} (${group2.length}個)`);
            
            // 各グループの最適な配置幅を計算
            const result1 = calculateOptimalGroupWidth(group1[0], container, clearance);
            const result2 = calculateOptimalGroupWidth(group2[0], container, clearance);
            
            // コンテナを左右に分割する最適な位置を探索
            let bestDivision = null;
            let maxPallets = 0;
            
            // 100x125と110x110の特殊ケース
            if ((group1[0].length === 100 && group1[0].width === 125 && group2[0].length === 110) ||
                (group2[0].length === 100 && group2[0].width === 125 && group1[0].length === 110)) {
                
                // 100x125を左、110x110を右に配置
                const divX = 500; // 100x125用に約500cm確保
                const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                
                let leftPlaced, rightPlaced;
                if (group1[0].length === 100 && group1[0].width === 125) {
                    leftPlaced = placeGroupInArea(group1, leftArea, clearance, true);
                    rightPlaced = placeGroupInArea(group2, rightArea, clearance, false);
                } else {
                    leftPlaced = placeGroupInArea(group2, leftArea, clearance, true);
                    rightPlaced = placeGroupInArea(group1, rightArea, clearance, false);
                }
                
                bestDivision = { divX, leftPlaced, rightPlaced };
                maxPallets = leftPlaced.length + rightPlaced.length;
                
            } else {
                // 一般的なケースの分割位置探索
                const testDivisions = [];
                
                // 各グループの必要幅に基づいて候補を生成
                for (let i = 1; i <= 5; i++) {
                    testDivisions.push(result1.minWidth * i);
                    testDivisions.push(container.length - result2.minWidth * i);
                }
                
                // 重複を除去してソート
                const uniqueDivisions = [...new Set(testDivisions)]
                    .filter(d => d >= result1.minWidth && d <= container.length - result2.minWidth)
                    .sort((a, b) => a - b);
                
                // 各分割位置を試行
                uniqueDivisions.forEach(divX => {
                    const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                    const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                    
                    // 左側エリアにgroup1を配置
                    const leftPlaced = placeGroupInArea(group1, leftArea, clearance, true);
                    // 右側エリアにgroup2を配置
                    const rightPlaced = placeGroupInArea(group2, rightArea, clearance, false);
                    
                    const totalPlaced = leftPlaced.length + rightPlaced.length;
                    if (totalPlaced > maxPallets) {
                        maxPallets = totalPlaced;
                        bestDivision = { divX, leftPlaced, rightPlaced };
                    }
                });
                
                // 左右を入れ替えた配置も試行
                uniqueDivisions.forEach(divX => {
                    const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                    const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                    
                    // 左側エリアにgroup2を配置
                    const leftPlaced = placeGroupInArea(group2, leftArea, clearance, true);
                    // 右側エリアにgroup1を配置
                    const rightPlaced = placeGroupInArea(group1, rightArea, clearance, false);
                    
                    const totalPlaced = leftPlaced.length + rightPlaced.length;
                    if (totalPlaced > maxPallets) {
                        maxPallets = totalPlaced;
                        bestDivision = { divX, leftPlaced, rightPlaced };
                    }
                });
            }
            
            // 最適な分割で配置
            if (bestDivision) {
                console.log(`最適分割位置: ${bestDivision.divX}cm, 配置数: ${maxPallets}個`);
                placedPallets.push(...bestDivision.leftPlaced);
                placedPallets.push(...bestDivision.rightPlaced);
            }
            
            return placedPallets;
        }
        
        // グループの最適配置幅を計算
        function calculateOptimalGroupWidth(samplePallet, container, clearance) {
            const orientations = samplePallet.length !== samplePallet.width ?
                [[samplePallet.length, samplePallet.width], [samplePallet.width, samplePallet.length]] :
                [[samplePallet.length, samplePallet.width]];
            
            let minWidth = Infinity;
            let maxCols = 0;
            
            orientations.forEach(([length, width]) => {
                const cols = Math.floor(container.length / (length + clearance));
                if (cols > 0) {
                    const requiredWidth = cols * (length + clearance) - clearance;
                    minWidth = Math.min(minWidth, length + clearance);
                    maxCols = Math.max(maxCols, cols);
                }
            });
            
            return { minWidth, maxCols };
        }
        
        // エリア内にグループを配置
        function placeGroupInArea(group, area, clearance, allowMixedOrientation) {
            const placed = [];
            const areaPlaced = [];
            
            // エリア内での最適な配置を計算
            const samplePallet = group[0];
            const orientations = samplePallet.length !== samplePallet.width ?
                [[samplePallet.length, samplePallet.width, false], [samplePallet.width, samplePallet.length, true]] :
                [[samplePallet.length, samplePallet.width, false]];
            
            let palletIndex = 0;
            
            // 混合配置を許可する場合（左側エリア）
            if (allowMixedOrientation && orientations.length > 1) {
                // 100×125パレットの特殊配置パターン
                if (samplePallet.length === 100 && samplePallet.width === 125) {
                    // 上部に横向き（125×100）を2列
                    let currentY = area.y;
                    
                    // 1列目：横向き2個
                    for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                        const x = area.x + i * 125;
                        if (x + 125 <= area.x + area.width) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x,
                                y: currentY,
                                finalLength: 125,
                                finalWidth: 100,
                                rotated: true,
                                placed: true
                            });
                            areaPlaced.push({ x, y: currentY, length: 125, width: 100 });
                        }
                    }
                    
                    currentY += 100 + clearance;
                    
                    // 2列目：縦向き（100×125）を2個
                    for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                        const x = area.x + i * 100;
                        if (x + 100 <= area.x + area.width) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x,
                                y: currentY,
                                finalLength: 100,
                                finalWidth: 125,
                                rotated: false,
                                placed: true
                            });
                            areaPlaced.push({ x, y: currentY, length: 100, width: 125 });
                        }
                    }
                    
                    // 3列目：下部に横向き2個 + 縦向き1個
                    if (palletIndex < group.length) {
                        currentY = area.y;
                        const x3Start = area.x + 250 + clearance;
                        
                        // 横向き2個（上下に配置）
                        for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                            const y = currentY + i * 100;
                            if (x3Start + 125 <= area.x + area.width && y + 100 <= area.y + area.height) {
                                const pallet = group[palletIndex++];
                                placed.push({
                                    ...pallet,
                                    x: x3Start,
                                    y: y,
                                    finalLength: 125,
                                    finalWidth: 100,
                                    rotated: true,
                                    placed: true
                                });
                                areaPlaced.push({ x: x3Start, y, length: 125, width: 100 });
                            }
                        }
                        
                    // 残りのパレットを配置（4列目）
                    if (palletIndex < group.length && area.width >= 500) {
                        const x4Start = 500;
                        
                        // 縦向き1個（右下）
                        if (palletIndex < group.length) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x4Start,
                                y: area.y,
                                finalLength: 100,
                                finalWidth: 125,
                                rotated: false,
                                placed: true
                            });
                            areaPlaced.push({ x: x4Start, y: area.y, length: 100, width: 125 });
                        }
                    }
                    }
                } else {
                    // その他のパレットの混合配置
                    let currentY = area.y;
                    
                    while (currentY < area.y + area.height && palletIndex < group.length) {
                        const useRotated = Math.floor((currentY - area.y) / 150) % 2 === 1;
                        const [length, width, rotated] = useRotated && orientations.length > 1 ? 
                            orientations[1] : orientations[0];
                        
                        let currentX = area.x;
                        let rowHeight = 0;
                        
                        while (currentX + length <= area.x + area.width && palletIndex < group.length) {
                            const pallet = group[palletIndex];
                            
                            if (canPlace2D(currentX, currentY, length, width, areaPlaced, clearance)) {
                                placed.push({
                                    ...pallet,
                                    x: currentX,
                                    y: currentY,
                                    finalLength: length,
                                    finalWidth: width,
                                    rotated: rotated,
                                    placed: true
                                });
                                
                                areaPlaced.push({
                                    x: currentX,
                                    y: currentY,
                                    length: length,
                                    width: width
                                });
                                
                                palletIndex++;
                                currentX += length + clearance;
                                rowHeight = Math.max(rowHeight, width);
                            } else {
                                break;
                            }
                        }
                        
                        currentY += rowHeight + clearance;
                    }
                }
            } else {
                // 単一向き配置（右側エリア用、110×110の整然配置）
                const [length, width, rotated] = orientations[0];
                const cols = Math.floor(area.width / (length + clearance));
                const rows = Math.floor(area.height / (width + clearance));
                
                let placedInArea = 0;
                for (let row = 0; row < rows && palletIndex < group.length; row++) {
                    for (let col = 0; col < cols && palletIndex < group.length; col++) {
                        const x = area.x + col * (length + clearance);
                        const y = area.y + row * (width + clearance);
                        const pallet = group[palletIndex];
                        
                        if (canPlace2D(x, y, length, width, areaPlaced, clearance)) {
                            placed.push({
                                ...pallet,
                                x: x,
                                y: y,
                                finalLength: length,
                                finalWidth: width,
                                rotated: rotated,
                                placed: true
                            });
                            
                            areaPlaced.push({
                                x: x,
                                y: y,
                                length: length,
                                width: width
                            });
                            
                            palletIndex++;
                            placedInArea++;
                        }
                    }
                }
                
                console.log(`${length}×${width}パレット: ${cols}列×${rows}行で${placedInArea}個配置`);
            }
            
            return placed;
        }

        // レンダリング関数
        function renderAllPallets(container) {
            const containerFloor = elements.containerFloor;
            const workArea = containerFloor.parentElement;
            
            renderConfig.scale = utils.calculateScale(container);
            const actualDisplayWidth = container.length * renderConfig.scale;
            const actualDisplayHeight = container.width * renderConfig.scale;
            
            // コンテナの表示設定
            containerFloor.style.width = `${actualDisplayWidth}px`;
            containerFloor.style.height = `${actualDisplayHeight}px`;
            containerFloor.style.position = 'absolute';
            containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            // 作業エリアのサイズ計算
            const unplacedPallets = allPalletsGenerated.filter(p => !p.deleted && !p.placed);
            let maxBottomY = actualDisplayHeight + CONSTANTS.CONTAINER_OFFSET_Y;
            
            if (unplacedPallets.length > 0) {
                const bottomMostY = Math.max(...unplacedPallets.map(p => 
                    ((p.y + p.finalWidth) * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y
                ));
                maxBottomY = Math.max(maxBottomY, bottomMostY + 50);
            }
            
            workArea.style.width = `${actualDisplayWidth + CONSTANTS.CONTAINER_OFFSET_X + 50}px`;
            workArea.style.height = `${Math.max(maxBottomY, 400 + CONSTANTS.CONTAINER_OFFSET_Y)}px`;
            workArea.style.position = 'relative';
            
            // 既存のパレットを削除
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // パレットを描画
            allPalletsGenerated.forEach(pallet => {
                if (pallet.deleted) return;
                
                const el = document.createElement('div');
                el.className = 'pallet-2d';
                el.dataset.palletId = pallet.id;
                el.dataset.instance = pallet.instance;
                
                const palletWidth = pallet.finalLength * renderConfig.scale;
                const palletHeight = pallet.finalWidth * renderConfig.scale;
                const palletLeft = (pallet.x * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_X;
                const palletTop = (pallet.y * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y;
                
                Object.assign(el.style, {
                    width: `${palletWidth}px`,
                    height: `${palletHeight}px`,
                    left: `${palletLeft}px`,
                    top: `${palletTop}px`,
                    background: pallet.color,
                    position: 'absolute'
                });
                
                if (pallet.rotated) {
                    el.style.background = `repeating-linear-gradient(45deg, ${pallet.color}, ${pallet.color} 10px, ${utils.adjustColor(pallet.color, -20)} 10px, ${utils.adjustColor(pallet.color, -20)} 20px)`;
                }
                
                // 状態に応じたクラス付与
                const isOutside = isOutsideContainer(pallet, container);
                const isBottomPlaced = pallet.y > container.width;
                
                if (isBottomPlaced) {
                    el.classList.add('bottom-placed');
                } else if (isOutside) {
                    el.classList.add('outside-container');
                }
                
                el.innerHTML = `
                    <div class="pallet-label">${pallet.finalLength}×${pallet.finalWidth}${pallet.rotated ? ' ↻' : ''}</div>
                    <div class="pallet-controls">
                        <button class="rotate-btn" title="回転">↻</button>
                        <button class="delete-btn" title="削除">✕</button>
                    </div>
                `;
                
                workArea.appendChild(el);
            });
            
            // レンダリング設定を保存
            renderConfig.containerBounds = {
                left: CONSTANTS.CONTAINER_OFFSET_X,
                top: CONSTANTS.CONTAINER_OFFSET_Y,
                width: actualDisplayWidth,
                height: actualDisplayHeight
            };
            
            enableDragAndDropAndActions();
        }

        function isOutsideContainer(pallet, container) {
            return pallet.x < 0 || pallet.y < 0 ||
                   pallet.x + pallet.finalLength > container.length ||
                   pallet.y + pallet.finalWidth > container.width;
        }

        // ドラッグ＆ドロップ機能
        let isDDListenerAttached = false;
        function enableDragAndDropAndActions() {
            const workArea = elements.containerFloor.parentElement;
            if (isDDListenerAttached) return;

            let activePalletEl = null;
            let initialMouseX, initialMouseY;

            workArea.addEventListener('mousedown', handleMouseDown);
            isDDListenerAttached = true;

            function handleMouseDown(e) {
                const target = e.target;
                if (target.classList.contains('rotate-btn')) {
                    e.stopPropagation();
                    rotatePallet(target.closest('.pallet-2d'));
                } else if (target.classList.contains('delete-btn')) {
                    e.stopPropagation();
                    deletePallet(target.closest('.pallet-2d'));
                } else {
                    const palletEl = target.classList.contains('pallet-2d') ? target : target.closest('.pallet-2d');
                    if (palletEl) {
                        dragStart(e, palletEl);
                    }
                }
            }

            function dragStart(e, palletEl) {
                e.preventDefault();
                activePalletEl = palletEl;
                activePalletEl.classList.add('dragging');
                
                const palletRect = activePalletEl.getBoundingClientRect();
                const workAreaRect = workArea.getBoundingClientRect();
                
                initialMouseX = e.clientX - palletRect.left;
                initialMouseY = e.clientY - palletRect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
            }

            function drag(e) {
                if (!activePalletEl) return;
                e.preventDefault();
                
                const workAreaRect = workArea.getBoundingClientRect();
                let newLeft = e.clientX - workAreaRect.left - initialMouseX;
                let newTop = e.clientY - workAreaRect.top - initialMouseY;
                
                // 作業エリア内に制限
                newLeft = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                          Math.min(newLeft, workArea.clientWidth - activePalletEl.clientWidth - CONSTANTS.MIN_DRAG_MARGIN));
                newTop = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                         Math.min(newTop, workArea.clientHeight - activePalletEl.clientHeight - CONSTANTS.MIN_DRAG_MARGIN));
                
                activePalletEl.style.left = `${newLeft}px`;
                activePalletEl.style.top = `${newTop}px`;
                
                updatePalletStatus(activePalletEl);
            }

            function dragEnd() {
                if (!activePalletEl) return;
                activePalletEl.classList.remove('dragging');
                updatePalletModel(activePalletEl);
                updateStats(containers[elements.containerType.value]);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                activePalletEl = null;
            }

            function rotatePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                // 寸法を入れ替え
                [palletData.finalLength, palletData.finalWidth] = [palletData.finalWidth, palletData.finalLength];
                palletData.rotated = !palletData.rotated;

                const container = containers[elements.containerType.value];
                palletEl.style.width = `${palletData.finalLength * renderConfig.scale}px`;
                palletEl.style.height = `${palletData.finalWidth * renderConfig.scale}px`;
                palletEl.querySelector('.pallet-label').textContent = 
                    `${palletData.finalLength}×${palletData.finalWidth}${palletData.rotated ? ' ↻' : ''}`;
                
                // 背景更新
                if (palletData.rotated) {
                    palletEl.style.background = `repeating-linear-gradient(45deg, ${palletData.color}, ${palletData.color} 10px, ${utils.adjustColor(palletData.color, -20)} 10px, ${utils.adjustColor(palletData.color, -20)} 20px)`;
                } else {
                    palletEl.style.background = palletData.color;
                }

                // 位置調整
                if (palletEl.offsetLeft + palletEl.offsetWidth > workArea.clientWidth) {
                    palletEl.style.left = `${Math.max(0, workArea.clientWidth - palletEl.offsetWidth)}px`;
                }
                if (palletEl.offsetTop + palletEl.offsetHeight > workArea.clientHeight) {
                    palletEl.style.top = `${Math.max(0, workArea.clientHeight - palletEl.offsetHeight)}px`;
                }
                
                updatePalletModel(palletEl);
                updatePalletStatus(palletEl);
                updateStats(container);
            }

            function deletePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                palletData.deleted = true;
                palletEl.remove();
                updateStats(containers[elements.containerType.value]);
                utils.showSuccess('パレットが削除されました');
            }

            function updatePalletStatus(palletEl) {
                const container = containers[elements.containerType.value];
                const palletData = {
                    x: (parseFloat(palletEl.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (parseFloat(palletEl.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    finalLength: palletEl.clientWidth / renderConfig.scale,
                    finalWidth: palletEl.clientHeight / renderConfig.scale
                };

                const isOutside = isOutsideContainer(palletData, container);
                const hasCollision = checkCollision(palletEl);
                
                palletEl.classList.toggle('outside-container', isOutside);
                palletEl.classList.toggle('colliding', hasCollision);
            }

            function checkCollision(draggedEl) {
                const container = containers[elements.containerType.value];
                const clearance = utils.getCurrentClearance();
                
                const draggedRect = {
                    x: (draggedEl.offsetLeft - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (draggedEl.offsetTop - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    length: draggedEl.clientWidth / renderConfig.scale,
                    width: draggedEl.clientHeight / renderConfig.scale
                };
                
                return allPalletsGenerated.some(p => {
                    if (p.deleted) return false;
                    const el = workArea.querySelector(`[data-pallet-id="${p.id}"][data-instance="${p.instance}"]`);
                    if (el === draggedEl) return false;
                    
                    return rectanglesOverlapWithClearance(
                        draggedRect,
                        { x: p.x, y: p.y, length: p.finalLength, width: p.finalWidth },
                        clearance
                    );
                });
            }

            function updatePalletModel(el) {
                const palletData = allPalletsGenerated.find(p =>
                    p.id == el.dataset.palletId && p.instance == el.dataset.instance
                );
                if (palletData) {
                    palletData.x = (parseFloat(el.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale;
                    palletData.y = (parseFloat(el.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale;
                }
            }
        }

        // 統計更新
        function updateStats(container) {
            const visiblePallets = allPalletsGenerated.filter(p => !p.deleted);
            const insidePallets = visiblePallets.filter(p => !isOutsideContainer(p, container));
            
            const containerArea = (container.length * container.width) / 10000; // m²
            const usedArea = insidePallets.reduce((sum, p) => 
                sum + (p.finalLength * p.finalWidth) / 10000, 0
            );
            
            const totalInputPallets = pallets.reduce((sum, p) => sum + p.qty, 0);
            
            document.getElementById('inputPallets').textContent = totalInputPallets;
            document.getElementById('visiblePallets').textContent = visiblePallets.length;
            document.getElementById('loadedPallets').textContent = insidePallets.length;
            document.getElementById('loadingRate').textContent = 
                `${totalInputPallets > 0 ? Math.round((insidePallets.length / totalInputPallets) * 100) : 0}%`;
            document.getElementById('efficiency').textContent = 
                `${containerArea > 0 ? Math.round((usedArea / containerArea) * 100) : 0}%`;
            document.getElementById('remainingArea').textContent = `${(containerArea - usedArea).toFixed(2)}m²`;
            
            elements.stats.style.display = 'grid';
        }

        function updateLegend() {
            elements.legend.innerHTML = '';
            if (pallets.length === 0) {
                elements.legend.style.display = 'none';
                return;
            }
            
            pallets.forEach(p => {
                elements.legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${p.color};"></div>
                        <span>${p.length}×${p.width}cm (${p.qty}個)</span>
                    </div>
                `;
            });
            elements.legend.style.display = 'flex';
        }

        // 画像エクスポート
        function exportLayoutAsImage() {
            const vizArea = document.querySelector('.visualization');
            elements.exportBtn.style.visibility = 'hidden';
            utils.showSuccess('🖼️ 画像を生成中です...');
            
            html2canvas(vizArea, { 
                scale: 2, 
                useCORS: true, 
                backgroundColor: '#ffffff' 
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `container-loading-plan-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                elements.exportBtn.style.visibility = 'visible';
            }).catch(err => {
                console.error('Image export failed:', err);
                utils.showError('画像の生成に失敗しました。');
                elements.exportBtn.style.visibility = 'visible';
            });
        }

        // イベントリスナーの設定
        function setupEventListeners() {
            elements.addPalletBtn.addEventListener('click', () => palletManager.add());
            elements.calculateBtn.addEventListener('click', calculateLoading);
            elements.testBtn.addEventListener('click', runTestCase);
            elements.exportBtn.addEventListener('click', exportLayoutAsImage);
            elements.containerType.addEventListener('change', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.clearanceValue.addEventListener('input', () => {
                updateContainerInfo();
                clearResults();
            });
            
            // Enterキーでの追加
            [elements.palletLength, elements.palletWidth, elements.palletQty].forEach(input => {
                input.addEventListener('keypress', e => {
                    if (e.key === 'Enter') palletManager.add();
                });
            });
        }

        function setupPresetButtons() {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.palletLength.value = this.dataset.length;
                    elements.palletWidth.value = this.dataset.width;
                    elements.palletQty.focus();
                });
            });
        }

        // 初期化
        function init() {
            setupPresetButtons();
            setupEventListeners();
            updateContainerInfo();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
