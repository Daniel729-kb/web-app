<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä½œæ¥­åŠ¹ç‡ç®¡ç†ãƒ‡ã‚¸ã‚¿ãƒ«ãƒ›ãƒ¯ã‚¤ãƒˆãƒœãƒ¼ãƒ‰</title>
    
    <!-- å…±é€šCSSãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ -->
    <link rel="stylesheet" href="../styles/variables.css">
    <link rel="stylesheet" href="../styles/components.css">
    <link rel="stylesheet" href="../styles/opwhiteboard.css">
</head>
            justify-content: space-between;
            align-items: center;


</head>
<body>
    <div class="container">
        <div class="header-controls">
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ">
                <span class="dark-mode-icon">ğŸŒ™</span>
            </button>
        </div>
        <h1>ä½œæ¥­åŠ¹ç‡ç®¡ç†ãƒœãƒ¼ãƒ‰</h1>

        <div class="improvement-note">
            <h3>ğŸ“‹ ä½¿ç”¨æ–¹æ³•</h3>
            <ul>
                <li><strong>ä½œæ¥­å“¡è¿½åŠ </strong>ï¼šåå‰ã‚’å…¥åŠ›ã—ã¦ã€Œâ• è¿½åŠ ã€ãƒœã‚¿ãƒ³ã§ä½œæ¥­å“¡ã‚’ç™»éŒ²</li>
                <li><strong>ä½œæ¥­å†…å®¹è¿½åŠ </strong>ï¼šä½œæ¥­å†…å®¹ã‚’å…¥åŠ›ã—ã¦æ–°ã—ã„ä½œæ¥­ã‚¨ãƒªã‚¢ã‚’ä½œæˆ</li>
                <li><strong>ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—</strong>ï¼šä½œæ¥­å“¡ã‚«ãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ä½œæ¥­ã‚¨ãƒªã‚¢é–“ã§ç§»å‹•</li>
                <li><strong>æ™‚é–“ç®¡ç†</strong>ï¼šä½œæ¥­é–‹å§‹ãƒ»çµ‚äº†æ™‚åˆ»ã‚’è‡ªå‹•è¨˜éŒ²ã€ä½œæ¥­æ™‚é–“ã‚’è¨ˆæ¸¬</li>
                <li><strong>ãƒ­ã‚°ç¢ºèª</strong>ï¼šä¸‹éƒ¨ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ä½œæ¥­å±¥æ­´ã‚’ç¢ºèª</li>
                <li><strong>CSVå‡ºåŠ›</strong>ï¼šä½œæ¥­ãƒ­ã‚°ã‚’CSVãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</li>
                <li><strong>ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ</strong>ï¼šCSVãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ä¸€æ‹¬ãƒ‡ãƒ¼ã‚¿å…¥åŠ›</li>
            </ul>
        </div>

        <!-- ã‚¨ãƒ©ãƒ¼è¡¨ç¤º -->
        <div id="errors"></div>

        <div class="control-panel">
            <div class="control-section">
                <h3>ä½œæ¥­å“¡è¿½åŠ </h3>
                <div class="input-group">
                    <input type="text" id="workerNameInput" placeholder="åå‰ã‚’å…¥åŠ›" class="form-input">
                    <button class="btn btn-primary" onclick="addWorker()">
                        <span>ï¼‹</span> è¿½åŠ 
                    </button>
                </div>
            </div>

            <div class="control-section">
                <h3>ä½œæ¥­å†…å®¹è¿½åŠ </h3>
                <div class="input-group">
                    <input type="text" id="workAreaInput" placeholder="ä½œæ¥­å†…å®¹ã‚’å…¥åŠ›" class="form-input">
                    <button class="btn btn-success" onclick="addWorkArea()">
                        <span>ï¼‹</span> è¿½åŠ 
                    </button>
                </div>
            </div>

            <button class="btn btn-purple" onclick="exportToCSV()">
                <span>ğŸ“¥</span> CSVå‡ºåŠ›
            </button>
        </div>

        <div class="import-section">
            <h3>ãƒ‡ãƒ¼ã‚¿ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</h3>
            <div class="import-buttons">
                <button class="btn btn-secondary" onclick="downloadTemplate('workers')">
                    <span>ğŸ“„</span> ä½œæ¥­å“¡ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
                </button>
                <button class="btn btn-secondary" onclick="downloadTemplate('areas')">
                    <span>ğŸ“„</span> ä½œæ¥­å†…å®¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
                </button>
                <label class="btn-import">
                    <span>ğŸ“¤</span> CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆ
                    <input type="file" id="csvImport" accept=".csv" onchange="handleFileImport(event)" style="display: none;">
                </label>
            </div>
        </div>

        <div class="whiteboard" id="whiteboard"></div>

        <div class="logs-section">
            <h2>ä½œæ¥­ãƒ­ã‚°</h2>
            <table class="table" id="logsTable">
                <thead>
                    <tr>
                        <th>ä½œæ¥­å“¡</th>
                        <th>ä½œæ¥­å†…å®¹</th>
                        <th>é–‹å§‹æ™‚åˆ»</th>
                        <th>çµ‚äº†æ™‚åˆ»</th>
                        <th>ä½œæ¥­æ™‚é–“</th>
                    </tr>
                </thead>
                <tbody id="logsBody">
                    <tr>
                        <td colspan="5" class="empty-logs">ã¾ã ä½œæ¥­ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script src="./app.js"></script>
    <script>
        // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
        let isDarkMode = false;

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            updateDarkModeIcon();
        }

        function updateDarkModeIcon() {
            const icon = document.querySelector('.dark-mode-icon');
            if (icon) {
                icon.textContent = isDarkMode ? 'â˜€ï¸' : 'ğŸŒ™';
            }
        }

        function initializeDarkMode() {
            document.body.classList.remove('dark-mode');
            isDarkMode = false;
            updateDarkModeIcon();
        }

        // åˆæœŸãƒ‡ãƒ¼ã‚¿
        let workers = [
            { id: 1, name: 'ç”°ä¸­å¤ªéƒ' },
            { id: 2, name: 'å±±ç”°èŠ±å­' },
            { id: 3, name: 'éˆ´æœ¨ä¸€éƒ' }
        ];

        let workAreas = [
            { id: 'waiting', name: 'å¾…æ©Ÿã‚¨ãƒªã‚¢', color: 'waiting' },
            { id: 'taskA', name: 'ä½œæ¥­å†…å®¹A', color: 'blue' },
            { id: 'taskB', name: 'ä½œæ¥­å†…å®¹B', color: 'green' }
        ];

        let workerPositions = {};
        let workLogs = [];
        let activeTimers = {};
        let timerIntervals = {};
        let elapsedTimes = {};

        // ã‚¿ãƒƒãƒãƒ‰ãƒ©ãƒƒã‚°ç”¨å¤‰æ•°
        let touchItem = null;
        let touchOffset = { x: 0, y: 0 };
        let isDragging = false;
        let touchStartTime = 0;
        let draggedWorkerId = null;

        // åˆæœŸåŒ–
        function init() {
            workers.forEach(worker => {
                workerPositions[worker.id] = 'waiting';
            });
            renderWhiteboard();
            startGlobalTimer();
        }

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¿ã‚¤ãƒãƒ¼
        function startGlobalTimer() {
            setInterval(() => {
                Object.keys(activeTimers).forEach(workerId => {
                    const elapsed = Math.floor((Date.now() - activeTimers[workerId]) / 1000);
                    updateTimerDisplay(workerId, elapsed);
                });
            }, 1000);
        }

        // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤ºæ›´æ–°
        function updateTimerDisplay(workerId, seconds) {
            const timerElement = document.getElementById(`timer-${workerId}`);
            if (timerElement) {
                timerElement.textContent = formatTime(seconds);
            }
        }

        // æ™‚é–“ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        // ãƒ›ãƒ¯ã‚¤ãƒˆãƒœãƒ¼ãƒ‰æç”»
        function renderWhiteboard() {
            const whiteboard = document.getElementById('whiteboard');
            whiteboard.innerHTML = '';

            workAreas.forEach(area => {
                const areaDiv = document.createElement('div');
                areaDiv.className = `work-area ${area.color}`;
                areaDiv.id = `area-${area.id}`;
                areaDiv.ondragover = handleDragOver;
                areaDiv.ondrop = (e) => handleDrop(e, area.id);
                areaDiv.ondragenter = handleDragEnter;
                areaDiv.ondragleave = handleDragLeave;

                const header = document.createElement('div');
                header.className = 'area-header';

                const title = document.createElement('div');
                title.className = 'area-title';
                title.id = `title-${area.id}`;
                title.textContent = area.name;

                const controls = document.createElement('div');
                controls.className = 'area-controls';

                if (area.id !== 'waiting') {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'icon-btn';
                    editBtn.textContent = 'âœï¸';
                    editBtn.onclick = () => editAreaName(area.id);

                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'icon-btn delete';
                    deleteBtn.textContent = 'âŒ';
                    deleteBtn.onclick = () => removeWorkArea(area.id);

                    controls.appendChild(editBtn);
                    controls.appendChild(deleteBtn);
                }

                header.appendChild(title);
                header.appendChild(controls);
                areaDiv.appendChild(header);

                const workersContainer = document.createElement('div');
                workersContainer.className = 'workers-container';

                workers.filter(w => workerPositions[w.id] === area.id).forEach(worker => {
                    const workerCard = createWorkerCard(worker);
                    workersContainer.appendChild(workerCard);
                });

                areaDiv.appendChild(workersContainer);
                whiteboard.appendChild(areaDiv);
            });
        }

        // ä½œæ¥­å“¡ã‚«ãƒ¼ãƒ‰ä½œæˆ
        function createWorkerCard(worker) {
            const card = document.createElement('div');
            card.className = 'worker-card';
            card.id = `worker-${worker.id}`;
            card.draggable = true;
            card.ondragstart = (e) => handleDragStart(e, worker.id);
            card.ondragend = handleDragEnd;
            card.ontouchstart = (e) => handleTouchStart(e, worker.id);
            card.ontouchmove = handleTouchMove;
            card.ontouchend = handleTouchEnd;

            const nameSpan = document.createElement('span');
            nameSpan.className = 'worker-name';
            nameSpan.textContent = worker.name;

            const rightSection = document.createElement('div');
            rightSection.style.display = 'flex';
            rightSection.style.alignItems = 'center';
            rightSection.style.gap = '10px';

            if (activeTimers[worker.id]) {
                const timer = document.createElement('div');
                timer.className = 'timer';
                timer.innerHTML = `â±ï¸ <span id="timer-${worker.id}">00:00:00</span>`;
                rightSection.appendChild(timer);
            }

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-worker';
            deleteBtn.textContent = 'Ã—';
            deleteBtn.onclick = () => removeWorker(worker.id);

            rightSection.appendChild(deleteBtn);

            card.appendChild(nameSpan);
            card.appendChild(rightSection);

            return card;
        }

        // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã‚¤ãƒ™ãƒ³ãƒˆ
        function handleDragStart(e, workerId) {
            // Prevent conflicts with touch events
            if (isDragging || touchItem) {
                e.preventDefault();
                return false;
            }
            
            // Only handle if it's actually a mouse event
            if (e.type === 'dragstart' && e.pointerType === 'touch') {
                e.preventDefault();
                return false;
            }
            
            if (!isDragging) {
                draggedWorkerId = workerId;
                e.target.classList.add('dragging');
                e.dataTransfer.setData('text/plain', workerId);
            }
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedWorkerId = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            if (e.currentTarget.classList.contains('work-area')) {
                e.currentTarget.classList.add('dragover');
            }
        }

        function handleDragLeave(e) {
            if (e.currentTarget.classList.contains('work-area')) {
                e.currentTarget.classList.remove('dragover');
            }
        }

        // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
        function handleTouchStart(e, workerId) {
            if (e.touches.length !== 1) return; // ãƒãƒ«ãƒã‚¿ãƒƒãƒç„¡è¦–
            
            // Prevent mouse events from firing
            e.preventDefault();
            
            const touch = e.touches[0];
            touchItem = e.currentTarget;
            draggedWorkerId = workerId;
            touchStartTime = Date.now();
            isDragging = false;

            // ã‚¿ãƒƒãƒä½ç½®ã¨ã‚«ãƒ¼ãƒ‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
            const rect = touchItem.getBoundingClientRect();
            touchOffset.x = touch.clientX - rect.left;
            touchOffset.y = touch.clientY - rect.top;

            // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã¾ã§ã®é…å»¶ï¼ˆã‚¿ãƒƒãƒ—ã¨ãƒ‰ãƒ©ãƒƒã‚°ã®åŒºåˆ¥ï¼‰
            const dragStartTimer = setTimeout(() => {
                if (touchItem && !isDragging) {
                    isDragging = true;
                    touchItem.classList.add('dragging-touch');
                    touchItem.style.position = 'absolute';
                    touchItem.style.zIndex = '1000';
                    
                    // Add visual feedback
                    touchItem.style.transform = 'scale(1.05)';
                    touchItem.style.boxShadow = '0 8px 25px rgba(0,0,0,0.3)';
                }
            }, 200); // 200msã®é…å»¶
            
            // Store timer for cleanup
            touchItem.dragStartTimer = dragStartTimer;
        }

        function handleTouchMove(e) {
            if (!touchItem || !isDragging) return;
            e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
            
            // Prevent default touch behaviors
            e.stopPropagation();
            
            const touch = e.touches[0];

            // ã‚«ãƒ¼ãƒ‰ã®ä½ç½®ã‚’ã‚¿ãƒƒãƒä½ç½®ã«è¿½å¾“
            touchItem.style.left = `${touch.clientX - touchOffset.x}px`;
            touchItem.style.top = `${touch.clientY - touchOffset.y}px`;

            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            document.querySelectorAll('.work-area').forEach(area => area.classList.remove('dragover'));
            if (target && target.closest('.work-area')) {
                target.closest('.work-area').classList.add('dragover');
            }
        }

        function handleTouchEnd(e) {
            // Clear drag start timer if it exists
            if (touchItem && touchItem.dragStartTimer) {
                clearTimeout(touchItem.dragStartTimer);
                delete touchItem.dragStartTimer;
            }
            
            if (!touchItem || !isDragging) {
                touchItem = null;
                draggedWorkerId = null;
                return;
            }

            isDragging = false;
            touchItem.classList.remove('dragging-touch');
            touchItem.style.position = '';
            touchItem.style.left = '';
            touchItem.style.top = '';
            touchItem.style.zIndex = '';
            touchItem.style.transform = '';
            touchItem.style.boxShadow = '';

            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ç‰¹å®š
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetArea = target ? target.closest('.work-area') : null;

            document.querySelectorAll('.work-area').forEach(area => area.classList.remove('dragover'));

            if (targetArea) {
                const targetAreaId = targetArea.id.replace('area-', '');
                handleDrop({ preventDefault: () => {} }, targetAreaId);
            }

            touchItem = null;
            draggedWorkerId = null;
        }

        // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
        function handleDrop(e, targetAreaId) {
            e.preventDefault();
            if (e.currentTarget) {
                e.currentTarget.classList.remove('dragover');
            }

            if (!draggedWorkerId) return;

            const workerId = draggedWorkerId;
            const worker = workers.find(w => w.id === workerId);
            if (!worker) return; // ä½œæ¥­å“¡ãŒå­˜åœ¨ã—ãªã„å ´åˆ

            const currentArea = workerPositions[workerId];
            if (currentArea === targetAreaId) return;

            const targetArea = workAreas.find(a => a.id === targetAreaId);
            if (!targetArea) return; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¨ãƒªã‚¢ãŒå­˜åœ¨ã—ãªã„å ´åˆ

            // å¾…æ©Ÿã‚¨ãƒªã‚¢ã‹ã‚‰ä½œæ¥­ã‚¨ãƒªã‚¢ã¸ï¼ˆä½œæ¥­é–‹å§‹ï¼‰
            if (currentArea === 'waiting' && targetAreaId !== 'waiting') {
                activeTimers[workerId] = Date.now();
            }
            // ä½œæ¥­ã‚¨ãƒªã‚¢ã‹ã‚‰å¾…æ©Ÿã‚¨ãƒªã‚¢ã¸ï¼ˆä½œæ¥­çµ‚äº†ï¼‰
            else if (currentArea !== 'waiting' && targetAreaId === 'waiting') {
                if (activeTimers[workerId]) {
                    const startTime = activeTimers[workerId];
                    const endTime = Date.now();
                    const duration = Math.floor((endTime - startTime) / 1000);

                    const log = {
                        id: Date.now(),
                        workerName: worker.name,
                        workArea: workAreas.find(a => a.id === currentArea)?.name || 'ä¸æ˜',
                        startTime: new Date(startTime).toLocaleString('ja-JP'),
                        endTime: new Date(endTime).toLocaleString('ja-JP'),
                        duration: duration
                    };

                    workLogs.push(log);
                    delete activeTimers[workerId];
                    updateLogsTable();
                }
            }
            // ä½œæ¥­ã‚¨ãƒªã‚¢é–“ã®ç§»å‹•
            else if (currentArea !== 'waiting' && targetAreaId !== 'waiting') {
                if (activeTimers[workerId]) {
                    const startTime = activeTimers[workerId];
                    const endTime = Date.now();
                    const duration = Math.floor((endTime - startTime) / 1000);

                    const log = {
                        id: Date.now(),
                        workerName: worker.name,
                        workArea: workAreas.find(a => a.id === currentArea)?.name || 'ä¸æ˜',
                        startTime: new Date(startTime).toLocaleString('ja-JP'),
                        endTime: new Date(endTime).toLocaleString('ja-JP'),
                        duration: duration
                    };

                    workLogs.push(log);
                    activeTimers[workerId] = Date.now();
                    updateLogsTable();
                }
            }

            workerPositions[workerId] = targetAreaId;
            renderWhiteboard();
        }

        // ä½œæ¥­å“¡è¿½åŠ 
        function addWorker() {
            try {
                const input = document.getElementById('workerNameInput');
                const name = input.value.trim();
                
                if (!name) {
                    showAlert('ä½œæ¥­å“¡åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                if (name.length > 20) {
                    showAlert('ä½œæ¥­å“¡åã¯20æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                // Check for duplicate names
                if (workers.some(w => w.name === name)) {
                    showAlert('åŒã˜åå‰ã®ä½œæ¥­å“¡ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™', 'warning');
                    return;
                }

                const newWorker = {
                    id: Date.now(),
                    name: name
                };

                workers.push(newWorker);
                workerPositions[newWorker.id] = 'waiting';
                input.value = '';
                renderWhiteboard();
                showAlert(`ä½œæ¥­å“¡ã€Œ${name}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, 'success');
            } catch (error) {
                console.error('Error adding worker:', error);
                showAlert('ä½œæ¥­å“¡ã®è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
            }
        }

        // ä½œæ¥­å“¡å‰Šé™¤
        function removeWorker(workerId) {
            workers = workers.filter(w => w.id !== workerId);
            delete workerPositions[workerId];
            delete activeTimers[workerId];
            renderWhiteboard();
        }

        // ä½œæ¥­ã‚¨ãƒªã‚¢è¿½åŠ 
        function addWorkArea() {
            try {
                const input = document.getElementById('workAreaInput');
                const name = input.value.trim();
                
                if (!name) {
                    showAlert('ä½œæ¥­å†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                if (name.length > 30) {
                    showAlert('ä½œæ¥­å†…å®¹ã¯30æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„', 'warning');
                    return;
                }
                
                // Check for duplicate names
                if (workAreas.some(a => a.name === name)) {
                    showAlert('åŒã˜åå‰ã®ä½œæ¥­ã‚¨ãƒªã‚¢ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™', 'warning');
                    return;
                }

                const colors = ['yellow', 'purple', 'pink', 'blue', 'green'];
                const newArea = {
                    id: `task_${Date.now()}`,
                    name: name,
                    color: colors[workAreas.length % colors.length]
                };

                workAreas.push(newArea);
                input.value = '';
                renderWhiteboard();
                showAlert(`ä½œæ¥­ã‚¨ãƒªã‚¢ã€Œ${name}ã€ã‚’è¿½åŠ ã—ã¾ã—ãŸ`, 'success');
            } catch (error) {
                console.error('Error adding work area:', error);
                showAlert('ä½œæ¥­ã‚¨ãƒªã‚¢ã®è¿½åŠ ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
            }
        }

        // ä½œæ¥­ã‚¨ãƒªã‚¢å‰Šé™¤
        function removeWorkArea(areaId) {
            if (areaId === 'waiting') return;

            Object.entries(workerPositions).forEach(([workerId, position]) => {
                if (position === areaId) {
                    workerPositions[workerId] = 'waiting';
                    delete activeTimers[workerId];
                }
            });

            workAreas = workAreas.filter(a => a.id !== areaId);
            renderWhiteboard();
        }

        // ã‚¨ãƒªã‚¢åç·¨é›†
        function editAreaName(areaId) {
            const titleElement = document.getElementById(`title-${areaId}`);
            const currentName = titleElement.textContent;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-input';
            input.value = currentName;
            
            input.onblur = () => saveAreaName(areaId, input.value);
            input.onkeypress = (e) => {
                if (e.key === 'Enter') {
                    saveAreaName(areaId, input.value);
                }
            };

            titleElement.innerHTML = '';
            titleElement.appendChild(input);
            input.focus();
        }

        function saveAreaName(areaId, newName) {
            const area = workAreas.find(a => a.id === areaId);
            if (area) {
                area.name = newName.trim() || area.name;
            }
            renderWhiteboard();
        }

        // ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«æ›´æ–°
        function updateLogsTable() {
            const tbody = document.getElementById('logsBody');
            
            if (workLogs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" class="empty-logs">ã¾ã ä½œæ¥­ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“</td></tr>';
                return;
            }

            const recentLogs = workLogs.slice(-10).reverse();
            tbody.innerHTML = recentLogs.map(log => `
                <tr>
                    <td>${log.workerName}</td>
                    <td>${log.workArea}</td>
                    <td>${log.startTime}</td>
                    <td>${log.endTime}</td>
                    <td>${formatTime(log.duration)}</td>
                </tr>
            `).join('');
        }

        // CSVå‡ºåŠ›
        function exportToCSV() {
            try {
                if (workLogs.length === 0) {
                    alert('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ä½œæ¥­ãƒ­ã‚°ãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }

                const headers = ['ä½œæ¥­å“¡å', 'ä½œæ¥­å†…å®¹', 'é–‹å§‹æ™‚åˆ»', 'çµ‚äº†æ™‚åˆ»', 'ä½œæ¥­æ™‚é–“(ç§’)'];
                const rows = workLogs.map(log => [
                    `"${log.workerName}"`,
                    `"${log.workArea}"`,
                    `"${log.startTime}"`,
                    `"${log.endTime}"`,
                    log.duration
                ]);

                const csvContent = [
                    headers.join(','),
                    ...rows.map(row => row.join(','))
                ].join('\n');

                const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `ä½œæ¥­ãƒ­ã‚°_${new Date().toLocaleDateString('ja-JP').replace(/\//g, '-')}.csv`;
                link.click();
                
                showAlert('ä½œæ¥­ãƒ­ã‚°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('CSVã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
            }
        }

        // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
        function downloadTemplate(type) {
            let csvContent = '';
            let filename = '';

            if (type === 'workers') {
                csvContent = 'ä½œæ¥­å“¡å\nç”°ä¸­å¤ªéƒ\nå±±ç”°èŠ±å­\néˆ´æœ¨ä¸€éƒ';
                filename = 'ä½œæ¥­å“¡ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ.csv';
            } else if (type === 'areas') {
                csvContent = 'ä½œæ¥­å†…å®¹,è‰²\nä½œæ¥­å†…å®¹A,blue\nä½œæ¥­å†…å®¹B,green\nä½œæ¥­å†…å®¹C,yellow';
                filename = 'ä½œæ¥­å†…å®¹ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ.csv';
            }

            const blob = new Blob(['\uFEFF' + csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            link.click();
        }

        // CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆå‡¦ç†
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                processCSV(content);
            };
            reader.readAsText(file, 'UTF-8');
            
            event.target.value = '';
        }

        // CSVå‡¦ç†ï¼ˆç°¡ç•¥ç‰ˆï¼‰
        function processCSV(content) {
            try {
                const lines = content.split('\n');
                if (lines.length < 2) {
                    showAlert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“', 'error');
                    return;
                }
                
                const header = lines[0].toLowerCase();
                
                // Check if it's a worker CSV or work area CSV
                if (header.includes('ä½œæ¥­å“¡') || header.includes('worker')) {
                    processWorkerCSV(lines);
                } else if (header.includes('ä½œæ¥­å†…å®¹') || header.includes('work') || header.includes('area')) {
                    processWorkAreaCSV(lines);
                } else {
                    showAlert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®å½¢å¼ãŒèªè­˜ã§ãã¾ã›ã‚“', 'error');
                }
            } catch (error) {
                console.error('Error processing CSV:', error);
                showAlert('CSVãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
            }
        }
        
        function processWorkerCSV(lines) {
            let imported = 0;
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const name = line.split(',')[0].trim().replace(/"/g, '');
                if (name && !workers.some(w => w.name === name)) {
                    workers.push({
                        id: Date.now() + i,
                        name: name
                    });
                    workerPositions[Date.now() + i] = 'waiting';
                    imported++;
                }
            }
            
            if (imported > 0) {
                renderWhiteboard();
                showAlert(`${imported}åã®ä½œæ¥­å“¡ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`, 'success');
            } else {
                showAlert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ä½œæ¥­å“¡ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'warning');
            }
        }
        
        function processWorkAreaCSV(lines) {
            let imported = 0;
            const colors = ['yellow', 'purple', 'pink', 'blue', 'green'];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(',');
                const name = parts[0].trim().replace(/"/g, '');
                const color = parts[1] ? parts[1].trim().replace(/"/g, '') : colors[imported % colors.length];
                
                if (name && !workAreas.some(a => a.name === name)) {
                    workAreas.push({
                        id: `task_${Date.now()}_${i}`,
                        name: name,
                        color: colors.includes(color) ? color : colors[imported % colors.length]
                    });
                    imported++;
                }
            }
            
            if (imported > 0) {
                renderWhiteboard();
                showAlert(`${imported}å€‹ã®ä½œæ¥­ã‚¨ãƒªã‚¢ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ`, 'success');
            } else {
                showAlert('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ä½œæ¥­ã‚¨ãƒªã‚¢ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸ', 'warning');
            }
        }
        
        // Alert function for better user feedback
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 6px;
                font-weight: 500;
                z-index: 10000;
                max-width: 300px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                animation: slideInRight 0.3s ease;
            `;
            
            const colors = {
                error: { bg: '#fef2f2', border: '#fecaca', text: '#dc2626' },
                warning: { bg: '#fffbeb', border: '#fed7aa', text: '#d97706' },
                success: { bg: '#f0fdf4', border: '#bbf7d0', text: '#16a34a' },
                info: { bg: '#eff6ff', border: '#bfdbfe', text: '#2563eb' }
            };
            
            const color = colors[type] || colors.info;
            alertDiv.style.backgroundColor = color.bg;
            alertDiv.style.borderLeft = `4px solid ${color.border}`;
            alertDiv.style.color = color.text;
            alertDiv.textContent = message;
            
            document.body.appendChild(alertDiv);
            
            // Auto remove after 3 seconds (safe timer usage)
            memoryManager.setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.style.animation = 'slideOutRight 0.3s ease';
                    memoryManager.setTimeout(() => {
                        if (alertDiv.parentNode) {
                            alertDiv.parentNode.removeChild(alertDiv);
                        }
                    }, 300);
                }
            }, 3000);
        }

        // ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
        const memoryManager = {
            // ã‚¿ã‚¤ãƒãƒ¼ã®è¿½è·¡
            timers: new Set(),
            
            // å®‰å…¨ãªã‚¿ã‚¤ãƒãƒ¼è¨­å®š
            setTimeout: (callback, delay) => {
                const timerId = setTimeout(callback, delay);
                memoryManager.timers.add(timerId);
                return timerId;
            },
            
            // ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¯ãƒªã‚¢
            clearTimeout: (timerId) => {
                clearTimeout(timerId);
                memoryManager.timers.delete(timerId);
            },
            
            // å…¨ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¯ãƒªã‚¢
            clearAllTimers: () => {
                memoryManager.timers.forEach(timerId => {
                    clearTimeout(timerId);
                });
                memoryManager.timers.clear();
            },
            
            // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanup: () => {
                memoryManager.clearAllTimers();
                
                // å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã‚¯ãƒªã‚¢
                if (workers && workers.length > 1000) {
                    console.log('Large worker dataset detected, clearing old data...');
                    workers = workers.slice(-500);
                }
                
                if (workAreas && workAreas.length > 100) {
                    console.log('Large work area dataset detected, clearing old data...');
                    workAreas = workAreas.slice(-100);
                }
                
                // æœªä½¿ç”¨ã®DOMè¦ç´ ã®ã‚¯ãƒªã‚¢
                const unusedElements = document.querySelectorAll('.temp-element, .calculation-result');
                if (unusedElements.length > 50) {
                    console.log('Clearing unused DOM elements...');
                    unusedElements.forEach(el => el.remove());
                }
            }
        };

        // Enterã‚­ãƒ¼ã§è¿½åŠ 
        document.addEventListener('DOMContentLoaded', () => {
            initializeDarkMode();
            
            document.getElementById('workerNameInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addWorker();
            });
            
            document.getElementById('workAreaInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') addWorkArea();
            });

            init();
            
            // å®šæœŸçš„ãªãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆ6åˆ†ã”ã¨ï¼‰
            setInterval(() => {
                memoryManager.cleanup();
            }, 6 * 60 * 1000);
        });
        
        // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('beforeunload', () => {
            console.log('Cleaning up whiteboard before page unload...');
            memoryManager.cleanup();
        });
    </script>
</body>
</html>