<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Automate Container Loader Planner - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- 共通CSSファイルの読み込み -->
    <link rel="stylesheet" href="../styles/variables.css">
    <link rel="stylesheet" href="../styles/components.css">
    <link rel="stylesheet" href="container-specific.css">
</head>
<body>
    <div class="container">
        <!-- ヘッダーコントロール -->
        <div class="header-controls" style="position: absolute; top: 24px; right: 32px; display: flex; gap: 12px; align-items: center; z-index: 10;">
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="ダークモード切り替え" style="background: rgba(255, 255, 255, 0.1); border: none; border-radius: 6px; padding: 8px; color: rgba(255, 255, 255, 0.8); cursor: pointer; transition: all 0.2s ease; font-size: 16px; display: flex; align-items: center; justify-content: center; width: 36px; height: 32px;">
                <span class="dark-mode-icon">🌙</span>
            </button>
        </div>

        <div class="header">
            <h1>📦 コンテナ積載プランナー（高さ調整対応版）</h1>
            <p>パフォーマンス改善・バグ修正・高さ差調整機能を実装した改良バージョン</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="form-group">
                    <label for="containerType">コンテナタイプ</label>
                    <select id="containerType" class="form-select">
                        <option value="20ft">20ftコンテナ (5.898m × 2.352m 内寸)</option>
                        <option value="40ft">40ftコンテナ (12.032m × 2.350m 内寸)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>パレット寸法 (cm)</label>
                    <div class="dimensions-grid">
                        <input id="palletLength" max="300" min="1" placeholder="長さ" type="number" class="form-input"/>
                        <input id="palletWidth" max="300" min="1" placeholder="幅" type="number" class="form-input"/>
                    </div>
                    <div class="preset-pallets">
                        <button class="preset-btn" data-length="120" data-width="100" type="button">
                            EUR<br/>(120×100)
                        </button>
                        <button class="preset-btn" data-length="120" data-width="80" type="button">
                            EUR2<br/>(120×80)
                        </button>
                        <button class="preset-btn" data-length="122" data-width="102" type="button">
                            US<br/>(122×102)
                        </button>
                        <button class="preset-btn" data-length="110" data-width="110" type="button">
                            正方形<br/>(110×110)
                        </button>
                        <button class="preset-btn" data-length="100" data-width="125" type="button">
                            カスタム<br/>(100×125)
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="palletQty">数量</label>
                    <input id="palletQty" max="100" min="1" placeholder="パレット数" type="number" value="1" class="form-input"/>
                </div>

                <!-- 高さ調整設定 -->
                <div class="height-adjustment-setting">
                    <h4>📏 高さ調整設定</h4>
                    <div class="height-adjustment-controls">
                        <div class="height-adjustment-input">
                            <label for="heightAdjustment">高さ調整値:</label>
                            <input id="heightAdjustment" type="number" min="0" max="50" step="0.5" value="0" class="form-input"/>
                            <span class="height-adjustment-unit">cm</span>
                        </div>
                        <div class="height-adjustment-info">
                            💡 同じ層内でのパレット高さを揃えるための底上げ調整値です。<br/>
                            パレット下部に挿入するスペーサーやクッション材の厚さを設定してください。
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="clearanceValue">クリアランス (cm)</label>
                    <input id="clearanceValue" max="50" min="0" placeholder="クリアランス" step="0.1" type="number" value="0" class="form-input"/>
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                        パレット間の最小間隔を設定（0.1cm刻み調整可能）<br/>
                        <strong>※計算時に適用されます（0=隙間なし配置で最大積載）</strong>
                    </small>
                </div>

                <button class="add-pallet-btn" id="addPalletBtn" type="button">➕ パレットタイプを追加</button>

                <div class="form-group">
                    <label>パレットリスト</label>
                    <div class="pallet-list" id="palletList">
                        <p style="text-align: center; color: #6c757d; font-style: italic;">パレットがまだ追加されていません</p>
                    </div>
                </div>

                <button class="test-btn" id="testBtn" type="button">🧪 テストケース実行</button>
                <button class="calculate-btn" id="calculateBtn" type="button">🔄 積載プランを計算</button>
                <button class="export-btn" id="exportBtn" style="display: none;" type="button">🖼️ 配置図を画像で保存</button>
            </div>

            <div class="visualization">
                <div class="error-message" id="errorMessage"></div>
                <div class="success-message" id="successMessage"></div>
                <div class="container-info" id="containerInfo">
                    コンテナタイプを選択してパレットを追加してください
                </div>

                <div class="loading-animation" id="loadingAnimation">
                    <div class="spinner"></div>
                    <p>最適な積載プランを計算中...</p>
                </div>

                <div class="manual-instructions" id="manualInstructions" style="display: none;">
                    <h4>📋 マニュアル調整ガイド</h4>
                    <ul>
                        <li>🖱️ パレットをドラッグして自由に位置調整</li>
                        <li>↻ 回転ボタンで向きを変更</li>
                        <li>📏 高さボタンで個別の高さ調整</li>
                        <li>🗑️ 削除ボタンで不要なパレットを除去</li>
                        <li>🔴 赤い枠線はコンテナ枠外配置を示します</li>
                        <li>🔵 青い枠線は高さ調整されたパレットを示します</li>
                        <li>📦 グレー枠線は下側配置（自動で配置されたもの）</li>
                        <li>🔄 同じサイズでも個別に向きや高さを変更可能</li>
                        <li>✨ 境界制限なし：コンテナ枠線ぴったりまで配置可能</li>
                    </ul>
                </div>

                <div class="legend" id="legend" style="display: none;"></div>
                <div class="unloaded-summary" id="unloadedSummary" style="display: none;"></div>

                <div class="container-view">
                    <div class="work-area">
                        <div class="container-floor" id="containerFloor"></div>
                    </div>
                </div>

                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-value" id="inputPallets">0</div>
                        <div class="stat-label">入力パレット数</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="visiblePallets">0</div>
                        <div class="stat-label">表示パレット数</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="loadedPallets">0</div>
                        <div class="stat-label">枠内パレット数</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="loadingRate">0%</div>
                        <div class="stat-label">積載率</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="efficiency">0%</div>
                        <div class="stat-label">床面効率</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="remainingArea">0m²</div>
                        <div class="stat-label">残り床面積</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalHeightAdjustment">0cm</div>
                        <div class="stat-label">総高さ調整</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ダークモード管理
        let isDarkMode = false;

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            updateDarkModeIcon();
        }

        function updateDarkModeIcon() {
            const icon = document.querySelector('.dark-mode-icon');
            if (icon) {
                icon.textContent = isDarkMode ? '☀️' : '🌙';
            }
        }

        function initializeDarkMode() {
            document.body.classList.remove('dark-mode');
            isDarkMode = false;
            updateDarkModeIcon();
        }

        // 定数の一元管理
        const CONSTANTS = {
            CONTAINER_OFFSET_X: 30,
            CONTAINER_OFFSET_Y: 30,
            CONTAINER_DISPLAY_WIDTH: 800,
            CONTAINER_DISPLAY_HEIGHT: 300,
            MIN_DRAG_MARGIN: 10,
            EPSILON: 0.01,
            ANIMATION_DELAY: 500
        };

        // グローバル変数
        let pallets = [];
        let allPalletsGenerated = [];
        let renderConfig = {
            scale: 1,
            containerOffset: { x: CONSTANTS.CONTAINER_OFFSET_X, y: CONSTANTS.CONTAINER_OFFSET_Y },
            containerBounds: null
        };

        const containers = {
            '20ft': { length: 589.8, width: 235.2 },
            '40ft': { length: 1203.2, width: 235.0 }
        };

        // DOM要素のキャッシュ
        const elements = {
            containerType: document.getElementById('containerType'),
            palletLength: document.getElementById('palletLength'),
            palletWidth: document.getElementById('palletWidth'),
            palletQty: document.getElementById('palletQty'),
            heightAdjustment: document.getElementById('heightAdjustment'),
            clearanceValue: document.getElementById('clearanceValue'),
            addPalletBtn: document.getElementById('addPalletBtn'),
            calculateBtn: document.getElementById('calculateBtn'),
            testBtn: document.getElementById('testBtn'),
            exportBtn: document.getElementById('exportBtn'),
            palletList: document.getElementById('palletList'),
            containerInfo: document.getElementById('containerInfo'),
            loadingAnimation: document.getElementById('loadingAnimation'),
            manualInstructions: document.getElementById('manualInstructions'),
            legend: document.getElementById('legend'),
            unloadedSummary: document.getElementById('unloadedSummary'),
            containerFloor: document.getElementById('containerFloor'),
            stats: document.getElementById('stats'),
            errorMessage: document.getElementById('errorMessage'),
            successMessage: document.getElementById('successMessage')
        };

        // ユーティリティ関数
        const utils = {
            getCurrentClearance: () => parseFloat(elements.clearanceValue.value) || 0,
            getCurrentHeightAdjustment: () => parseFloat(elements.heightAdjustment.value) || 0,
            getRandomColor: () => {
                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            showError: (message) => {
                elements.errorMessage.textContent = message;
                elements.errorMessage.style.display = 'block';
                setTimeout(() => elements.errorMessage.style.display = 'none', 5000);
            },
            showSuccess: (message) => {
                elements.successMessage.textContent = message;
                elements.successMessage.style.display = 'block';
                setTimeout(() => elements.successMessage.style.display = 'none', 5000);
            },
            adjustColor: (color, amount) => {
                return '#' + color.replace(/^#/, '').replace(/../g, value => 
                    ('0' + Math.min(255, Math.max(0, parseInt(value, 16) + amount)).toString(16)).substr(-2)
                );
            },
            calculateScale: (container) => {
                const scaleX = CONSTANTS.CONTAINER_DISPLAY_WIDTH / container.length;
                const scaleY = CONSTANTS.CONTAINER_DISPLAY_HEIGHT / container.width;
                return Math.min(scaleX, scaleY);
            }
        };

        // パレット管理
        const palletManager = {
            add: function() {
                const length = parseInt(elements.palletLength.value);
                const width = parseInt(elements.palletWidth.value);
                const qty = parseInt(elements.palletQty.value);
                const heightAdjustment = utils.getCurrentHeightAdjustment();
                
                if (!this.validate(length, width, qty)) return;
                
                pallets.push({
                    id: Date.now(),
                    length,
                    width,
                    qty,
                    heightAdjustment,
                    color: utils.getRandomColor()
                });
                
                updatePalletList();
                updateContainerInfo();
                clearInputs();
                clearResults();
            },
            
            validate: (length, width, qty) => {
                if (!length || !width || !qty || length <= 0 || width <= 0 || qty <= 0) {
                    utils.showError('有効なパレット寸法と数量を入力してください');
                    return false;
                }
                if (length > 300 || width > 300) {
                    utils.showError('パレットサイズは300cm以下にしてください');
                    return false;
                }
                if (qty > 100) {
                    utils.showError('パレット数量は100個以下にしてください');
                    return false;
                }
                return true;
            },
            
            remove: (id) => {
                pallets = pallets.filter(p => p.id !== id);
                updatePalletList();
                updateContainerInfo();
                clearResults();
            }
        };

        // テストケース
        function runTestCase() {
            pallets = [];
            allPalletsGenerated = [];
            elements.containerType.value = '40ft';
            elements.clearanceValue.value = '0';
            elements.heightAdjustment.value = '2.5';
            
            const testData = [
                { l: 110, w: 110, q: 12, h: 2.5, c: '#f39c12' },  // 黄色
                { l: 100, w: 125, q: 8, h: 1.0, c: '#3498db' }    // 青色
            ];
            
            testData.forEach((p, i) => pallets.push({
                id: Date.now() + i,
                length: p.l,
                width: p.w,
                qty: p.q,
                heightAdjustment: p.h,
                color: p.c
            }));
            
            updatePalletList();
            updateContainerInfo();
            clearResults();
            utils.showSuccess('🎯 高さ調整テスト: 110×110 (+2.5cm) + 100×125 (+1.0cm)');
        }

        // UI更新関数
        function updatePalletList() {
            elements.palletList.innerHTML = '';
            
            if (pallets.length === 0) {
                elements.palletList.innerHTML = '<p style="text-align:center;color:#6c757d;font-style:italic;">パレットがありません</p>';
                return;
            }
            
            pallets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'pallet-item';
                const heightInfo = p.heightAdjustment > 0 ? ` +${p.heightAdjustment}cm` : '';
                item.innerHTML = `<span>${p.length}×${p.width}cm (${p.qty}個)${heightInfo}</span><button class="remove-btn">✕</button>`;
                item.querySelector('.remove-btn').addEventListener('click', () => palletManager.remove(p.id));
                elements.palletList.appendChild(item);
            });
        }

        function updateContainerInfo() {
            const container = containers[elements.containerType.value];
            const heightAdjustment = utils.getCurrentHeightAdjustment();
            const heightInfo = heightAdjustment > 0 ? ` | 高さ調整: ${heightAdjustment}cm` : '';
            elements.containerInfo.innerHTML = `${elements.containerType.value}内寸: ${(container.length/100).toFixed(3)}m×${(container.width/100).toFixed(3)}m <small>クリアランス: ${utils.getCurrentClearance()}cm${heightInfo}</small>`;
        }

        function clearInputs() {
            elements.palletLength.value = '';
            elements.palletWidth.value = '';
            elements.palletQty.value = '1';
        }

        function clearResults() {
            allPalletsGenerated = [];
            const workArea = elements.containerFloor.parentElement;
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // レンダリング設定をリセット
            const container = containers[elements.containerType.value];
            renderConfig.scale = utils.calculateScale(container);
            
            elements.containerFloor.style.width = `${container.length * renderConfig.scale}px`;
            elements.containerFloor.style.height = `${container.width * renderConfig.scale}px`;
            elements.containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            elements.containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            ['stats', 'legend', 'unloadedSummary', 'exportBtn', 'manualInstructions'].forEach(id => {
                elements[id].style.display = 'none';
            });
        }

        // 配置アルゴリズム関連
        function canPlace2D(x, y, length, width, placed, clearance, container = null) {
            const rect1 = { x, y, length, width };
            const cont = container || containers[elements.containerType.value];
            
            // 境界チェック
            if (x < 0 || y < 0 || x + length > cont.length || y + width > cont.width) {
                return false;
            }
            
            // 衝突チェック
            return !placed.some(rect2 => rectanglesOverlapWithClearance(rect1, rect2, clearance));
        }

        function rectanglesOverlapWithClearance(r1, r2, clearance) {
            return !(
                r1.x + r1.length + clearance <= r2.x + CONSTANTS.EPSILON ||
                r2.x + r2.length + clearance <= r1.x + CONSTANTS.EPSILON ||
                r1.y + r1.width + clearance <= r2.y + CONSTANTS.EPSILON ||
                r2.y + r2.width + clearance <= r1.y + CONSTANTS.EPSILON
            );
        }

        function calculateLoading() {
            if (pallets.length === 0) {
                return utils.showError('少なくとも1つのパレットタイプを追加してください');
            }
            
            const container = containers[elements.containerType.value];
            const clearance = utils.getCurrentClearance();
            elements.loadingAnimation.style.display = 'block';
            elements.exportBtn.style.display = 'none';

            setTimeout(() => {
                allPalletsGenerated = [];
                
                // 全パレットを生成
                pallets.forEach(pt => {
                    for (let i = 0; i < pt.qty; i++) {
                        allPalletsGenerated.push({
                            id: pt.id,
                            instance: i,
                            length: pt.length,
                            width: pt.width,
                            heightAdjustment: pt.heightAdjustment,
                            color: pt.color,
                            placed: false,
                            deleted: false,
                            x: 0,
                            y: 0,
                            finalLength: pt.length,
                            finalWidth: pt.width,
                            rotated: false,
                            individualHeightAdjustment: pt.heightAdjustment // 個別調整用
                        });
                    }
                });
                
                console.log(`生成されたパレット数: ${allPalletsGenerated.length}`);
                console.log(`コンテナサイズ: ${container.length}cm × ${container.width}cm`);
                console.log(`クリアランス: ${clearance}cm`);
                
                // 自動配置
                packPallets2D(allPalletsGenerated.filter(p => !p.deleted), container, clearance);
                
                const placedCount = allPalletsGenerated.filter(p => p.placed).length;
                const rotatedCount = allPalletsGenerated.filter(p => p.placed && p.rotated).length;
                const heightAdjustedCount = allPalletsGenerated.filter(p => p.individualHeightAdjustment > 0).length;
                
                elements.loadingAnimation.style.display = 'none';
                elements.exportBtn.style.display = 'block';
                elements.manualInstructions.style.display = 'block';
                
                renderAllPallets(container);
                updateStats(container);
                updateLegend();

                let message = '';
                if (placedCount === allPalletsGenerated.length) {
                    message = `🎉 全${allPalletsGenerated.length}個のパレットが自動配置されました！`;
                } else if (placedCount > 0) {
                    message = `⚡ ${placedCount}/${allPalletsGenerated.length}個を自動配置。残りはマニュアル調整してください。`;
                } else {
                    message = `📦 ${allPalletsGenerated.length}個のパレットを生成しました。マニュアルで配置してください。`;
                }
                
                if (rotatedCount > 0) message += ` (回転: ${rotatedCount}個)`;
                if (heightAdjustedCount > 0) message += ` (高さ調整: ${heightAdjustedCount}個)`;
                
                utils.showSuccess(message);
            }, CONSTANTS.ANIMATION_DELAY);
        }

        // 簡略化された配置アルゴリズム（高さ調整対応）
        function packPallets2D(palletsToPlace, container, clearance) {
            const placed = [];
            
            // パレットをタイプごとにグループ化
            const groups = {};
            palletsToPlace.forEach(pallet => {
                const key = `${pallet.length}x${pallet.width}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(pallet);
            });
            
            console.log(`グループ数: ${Object.keys(groups).length}`);
            Object.entries(groups).forEach(([key, pallets]) => {
                console.log(`  ${key}: ${pallets.length}個`);
            });
            
            // 100×125パレットの特殊配置パターンを試行
            if (groups['100x125'] && groups['100x125'].length >= 8) {
                const specialPlaced = trySpecialPattern100x125(groups['100x125'], container, clearance);
                if (specialPlaced.length > 0) {
                    console.log(`100×125特殊パターンで ${specialPlaced.length} 個配置成功`);
                    specialPlaced.forEach(p => {
                        const original = allPalletsGenerated.find(pallet => 
                            pallet.id === p.id && pallet.instance === p.instance
                        );
                        if (original) {
                            original.placed = true;
                            original.x = p.x;
                            original.y = p.y;
                            original.finalLength = p.finalLength;
                            original.finalWidth = p.finalWidth;
                            original.rotated = p.rotated;
                        }
                        placed.push({
                            x: p.x,
                            y: p.y,
                            length: p.finalLength,
                            width: p.finalWidth
                        });
                    });
                }
            }
            
            // 110×110パレットをグリッド配置
            if (groups['110x110']) {
                const gridPlaced = placeGridPattern(groups['110x110'], container, clearance, placed);
                gridPlaced.forEach(p => {
                    const original = allPalletsGenerated.find(pallet => 
                        pallet.id === p.id && pallet.instance === p.instance
                    );
                    if (original) {
                        original.placed = true;
                        original.x = p.x;
                        original.y = p.y;
                        original.finalLength = p.finalLength;
                        original.finalWidth = p.finalWidth;
                        original.rotated = p.rotated;
                    }
                    placed.push({
                        x: p.x,
                        y: p.y,
                        length: p.finalLength,
                        width: p.finalWidth
                    });
                });
            }
            
            // 残りのパレットを通常配置
            const remainingPallets = palletsToPlace.filter(p => !p.placed);
            console.log(`残りパレット数: ${remainingPallets.length}`);
            
            // パレットをサイズでソート（大きいものから）
            remainingPallets.sort((a, b) => (b.length * b.width) - (a.length * a.width));
            
            remainingPallets.forEach(pallet => {
                let bestPosition = null;
                let bestScore = Infinity;
                let bestRotated = false;
                
                // 通常配置と回転配置の両方を試行
                const orientations = pallet.length !== pallet.width ?
                    [[pallet.length, pallet.width, false], [pallet.width, pallet.length, true]] :
                    [[pallet.length, pallet.width, false]];
                
                orientations.forEach(([length, width, rotated]) => {
                    // グリッドベースで配置位置を探索
                    for (let y = 0; y <= container.width - width; y += 5) {
                        for (let x = 0; x <= container.length - length; x += 5) {
                            if (canPlace2D(x, y, length, width, placed, clearance)) {
                                // 左下を優先するスコア計算
                                const score = x + y * 2;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPosition = { x, y };
                                    bestRotated = rotated;
                                }
                            }
                        }
                    }
                });
                
                if (bestPosition) {
                    pallet.placed = true;
                    pallet.x = bestPosition.x;
                    pallet.y = bestPosition.y;
                    pallet.rotated = bestRotated;
                    
                    if (bestRotated) {
                        pallet.finalLength = pallet.width;
                        pallet.finalWidth = pallet.length;
                    } else {
                        pallet.finalLength = pallet.length;
                        pallet.finalWidth = pallet.width;
                    }
                    
                    placed.push({
                        x: pallet.x,
                        y: pallet.y,
                        length: pallet.finalLength,
                        width: pallet.finalWidth
                    });
                }
            });
            
            console.log(`通常配置で追加配置: ${remainingPallets.filter(p => p.placed).length}個`);
            
            // 未配置パレットの整列
            const unplaced = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
            if (unplaced.length > 0) {
                console.log(`未配置パレット: ${unplaced.length}個`);
                let offsetX = 0;
                let offsetY = container.width + 30;
                let currentRowMaxHeight = 0;
                
                unplaced.forEach(pallet => {
                    if (offsetX + pallet.finalLength > container.length) {
                        offsetX = 0;
                        offsetY += currentRowMaxHeight + 10;
                        currentRowMaxHeight = 0;
                    }
                    
                    pallet.x = offsetX;
                    pallet.y = offsetY;
                    
                    currentRowMaxHeight = Math.max(currentRowMaxHeight, pallet.finalWidth);
                    offsetX += pallet.finalLength + 10;
                });
            }
        }

        // 100×125パレットの特殊配置パターン（高さ調整対応）
        function trySpecialPattern100x125(pallets, container, clearance) {
            const placedPallets = [];
            const areaPlaced = [];
            
            const pattern = [
                { row: 0, col: 0, rotated: true },
                { row: 0, col: 1, rotated: false },
                { row: 0, col: 2, rotated: true },
                { row: 0, col: 3, rotated: false },
                { row: 1, col: 0, rotated: false },
                { row: 1, col: 1, rotated: true },
                { row: 1, col: 2, rotated: false },
                { row: 1, col: 3, rotated: true }
            ];
            
            let palletIndex = 0;
            const startX = 0;
            const startY = 0;
            
            pattern.forEach((pos, index) => {
                if (palletIndex >= pallets.length) return;
                
                const pallet = pallets[palletIndex];
                let x, y, length, width;
                
                if (pos.row === 0) {
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 125 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 125 + 100 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 125 + 100 + 125 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY;
                } else {
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 100 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 100 + 125 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 100 + 125 + 100 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY + 125 + clearance;
                }
                
                if (x + length <= container.length && y + width <= container.width &&
                    canPlace2D(x, y, length, width, areaPlaced, 0)) {
                    
                    placedPallets.push({
                        ...pallet,
                        x: x,
                        y: y,
                        finalLength: length,
                        finalWidth: width,
                        rotated: pos.rotated,
                        placed: true
                    });
                    
                    areaPlaced.push({
                        x: x,
                        y: y,
                        length: length,
                        width: width
                    });
                    
                    palletIndex++;
                    console.log(`100×125 配置: ${pos.rotated ? '横' : '縦'}向き at (${x}, ${y})`);
                }
            });
            
            return placedPallets;
        }

        // グリッドパターン配置（110×110用、高さ調整対応）
        function placeGridPattern(pallets, container, clearance, alreadyPlaced) {
            const placedPallets = [];
            const length = 110;
            const width = 110;
            
            const startX = 500 + clearance;
            const startY = 0;
            
            const cols = Math.floor((container.length - startX) / (length + clearance));
            const rows = Math.floor(container.width / (width + clearance));
            
            let palletIndex = 0;
            
            for (let row = 0; row < rows && palletIndex < pallets.length; row++) {
                for (let col = 0; col < cols && palletIndex < pallets.length; col++) {
                    const x = startX + col * (length + clearance);
                    const y = startY + row * (width + clearance);
                    
                    if (canPlace2D(x, y, length, width, alreadyPlaced, clearance)) {
                        const pallet = pallets[palletIndex++];
                        placedPallets.push({
                            ...pallet,
                            x: x,
                            y: y,
                            finalLength: length,
                            finalWidth: width,
                            rotated: false,
                            placed: true
                        });
                    }
                }
            }
            
            console.log(`110×110 グリッド配置: ${cols}列×${rows}行で${placedPallets.length}個配置`);
            
            return placedPallets;
        }

        // レンダリング関数（高さ調整対応）
        function renderAllPallets(container) {
            const containerFloor = elements.containerFloor;
            const workArea = containerFloor.parentElement;
            
            renderConfig.scale = utils.calculateScale(container);
            const actualDisplayWidth = container.length * renderConfig.scale;
            const actualDisplayHeight = container.width * renderConfig.scale;
            
            containerFloor.style.width = `${actualDisplayWidth}px`;
            containerFloor.style.height = `${actualDisplayHeight}px`;
            containerFloor.style.position = 'absolute';
            containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            const unplacedPallets = allPalletsGenerated.filter(p => !p.deleted && !p.placed);
            let maxBottomY = actualDisplayHeight + CONSTANTS.CONTAINER_OFFSET_Y;
            
            if (unplacedPallets.length > 0) {
                const bottomMostY = Math.max(...unplacedPallets.map(p => 
                    ((p.y + p.finalWidth) * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y
                ));
                maxBottomY = Math.max(maxBottomY, bottomMostY + 50);
            }
            
            workArea.style.width = `${actualDisplayWidth + CONSTANTS.CONTAINER_OFFSET_X + 50}px`;
            workArea.style.height = `${Math.max(maxBottomY, 400 + CONSTANTS.CONTAINER_OFFSET_Y)}px`;
            workArea.style.position = 'relative';
            
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // パレットを描画（高さ調整表示対応）
            allPalletsGenerated.forEach(pallet => {
                if (pallet.deleted) return;
                
                const el = document.createElement('div');
                el.className = 'pallet-2d';
                el.dataset.palletId = pallet.id;
                el.dataset.instance = pallet.instance;
                
                const palletWidth = pallet.finalLength * renderConfig.scale;
                const palletHeight = pallet.finalWidth * renderConfig.scale;
                const palletLeft = (pallet.x * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_X;
                const palletTop = (pallet.y * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y;
                
                Object.assign(el.style, {
                    width: `${palletWidth}px`,
                    height: `${palletHeight}px`,
                    left: `${palletLeft}px`,
                    top: `${palletTop}px`,
                    background: pallet.color,
                    position: 'absolute'
                });
                
                if (pallet.rotated) {
                    el.style.background = `repeating-linear-gradient(45deg, ${pallet.color}, ${pallet.color} 10px, ${utils.adjustColor(pallet.color, -20)} 10px, ${utils.adjustColor(pallet.color, -20)} 20px)`;
                }
                
                // 状態に応じたクラス付与
                const isOutside = isOutsideContainer(pallet, container);
                const isBottomPlaced = pallet.y > container.width;
                const hasHeightAdjustment = pallet.individualHeightAdjustment > 0;
                
                if (isBottomPlaced) {
                    el.classList.add('bottom-placed');
                } else if (isOutside) {
                    el.classList.add('outside-container');
                }
                
                if (hasHeightAdjustment) {
                    el.classList.add('height-adjusted');
                }
                
                const heightInfo = hasHeightAdjustment ? ` +${pallet.individualHeightAdjustment}cm` : '';
                const rotationInfo = pallet.rotated ? ' ↻' : '';
                
                el.innerHTML = `
                    <div class="pallet-label">${pallet.finalLength}×${pallet.finalWidth}${rotationInfo}${heightInfo}</div>
                    <div class="pallet-controls">
                        <button class="rotate-btn" title="回転">↻</button>
                        <button class="height-btn" title="高さ調整">📏</button>
                        <button class="delete-btn" title="削除">✕</button>
                    </div>
                `;
                
                workArea.appendChild(el);
            });
            
            renderConfig.containerBounds = {
                left: CONSTANTS.CONTAINER_OFFSET_X,
                top: CONSTANTS.CONTAINER_OFFSET_Y,
                width: actualDisplayWidth,
                height: actualDisplayHeight
            };
            
            enableDragAndDropAndActions();
        }

        function isOutsideContainer(pallet, container) {
            return pallet.x < 0 || pallet.y < 0 ||
                   pallet.x + pallet.finalLength > container.length ||
                   pallet.y + pallet.finalWidth > container.width;
        }

        // ドラッグ＆ドロップ機能（高さ調整対応）
        let isDDListenerAttached = false;
        function enableDragAndDropAndActions() {
            const workArea = elements.containerFloor.parentElement;
            if (isDDListenerAttached) return;

            let activePalletEl = null;
            let initialMouseX, initialMouseY;

            workArea.addEventListener('mousedown', handleMouseDown);
            isDDListenerAttached = true;

            function handleMouseDown(e) {
                const target = e.target;
                if (target.classList.contains('rotate-btn')) {
                    e.stopPropagation();
                    rotatePallet(target.closest('.pallet-2d'));
                } else if (target.classList.contains('height-btn')) {
                    e.stopPropagation();
                    adjustPalletHeight(target.closest('.pallet-2d'));
                } else if (target.classList.contains('delete-btn')) {
                    e.stopPropagation();
                    deletePallet(target.closest('.pallet-2d'));
                } else {
                    const palletEl = target.classList.contains('pallet-2d') ? target : target.closest('.pallet-2d');
                    if (palletEl) {
                        dragStart(e, palletEl);
                    }
                }
            }

            function dragStart(e, palletEl) {
                e.preventDefault();
                activePalletEl = palletEl;
                activePalletEl.classList.add('dragging');
                
                const palletRect = activePalletEl.getBoundingClientRect();
                const workAreaRect = workArea.getBoundingClientRect();
                
                initialMouseX = e.clientX - palletRect.left;
                initialMouseY = e.clientY - palletRect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
            }

            function drag(e) {
                if (!activePalletEl) return;
                e.preventDefault();
                
                const workAreaRect = workArea.getBoundingClientRect();
                let newLeft = e.clientX - workAreaRect.left - initialMouseX;
                let newTop = e.clientY - workAreaRect.top - initialMouseY;
                
                newLeft = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                          Math.min(newLeft, workArea.clientWidth - activePalletEl.clientWidth - CONSTANTS.MIN_DRAG_MARGIN));
                newTop = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                         Math.min(newTop, workArea.clientHeight - activePalletEl.clientHeight - CONSTANTS.MIN_DRAG_MARGIN));
                
                activePalletEl.style.left = `${newLeft}px`;
                activePalletEl.style.top = `${newTop}px`;
                
                updatePalletStatus(activePalletEl);
            }

            function dragEnd() {
                if (!activePalletEl) return;
                activePalletEl.classList.remove('dragging');
                updatePalletModel(activePalletEl);
                updateStats(containers[elements.containerType.value]);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                activePalletEl = null;
            }

            function rotatePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                [palletData.finalLength, palletData.finalWidth] = [palletData.finalWidth, palletData.finalLength];
                palletData.rotated = !palletData.rotated;

                const container = containers[elements.containerType.value];
                palletEl.style.width = `${palletData.finalLength * renderConfig.scale}px`;
                palletEl.style.height = `${palletData.finalWidth * renderConfig.scale}px`;
                
                const heightInfo = palletData.individualHeightAdjustment > 0 ? ` +${palletData.individualHeightAdjustment}cm` : '';
                const rotationInfo = palletData.rotated ? ' ↻' : '';
                palletEl.querySelector('.pallet-label').textContent = 
                    `${palletData.finalLength}×${palletData.finalWidth}${rotationInfo}${heightInfo}`;
                
                if (palletData.rotated) {
                    palletEl.style.background = `repeating-linear-gradient(45deg, ${palletData.color}, ${palletData.color} 10px, ${utils.adjustColor(palletData.color, -20)} 10px, ${utils.adjustColor(palletData.color, -20)} 20px)`;
                } else {
                    palletEl.style.background = palletData.color;
                }

                if (palletEl.offsetLeft + palletEl.offsetWidth > workArea.clientWidth) {
                    palletEl.style.left = `${Math.max(0, workArea.clientWidth - palletEl.offsetWidth)}px`;
                }
                if (palletEl.offsetTop + palletEl.offsetHeight > workArea.clientHeight) {
                    palletEl.style.top = `${Math.max(0, workArea.clientHeight - palletEl.offsetHeight)}px`;
                }
                
                updatePalletModel(palletEl);
                updatePalletStatus(palletEl);
                updateStats(container);
            }

            function adjustPalletHeight(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                const currentHeight = palletData.individualHeightAdjustment || 0;
                const newHeight = prompt(
                    `パレットの高さ調整値を入力してください (現在: ${currentHeight}cm)`, 
                    currentHeight
                );
                
                if (newHeight !== null && !isNaN(parseFloat(newHeight))) {
                    const heightValue = Math.max(0, Math.min(50, parseFloat(newHeight)));
                    palletData.individualHeightAdjustment = heightValue;
                    
                    // 表示更新
                    const heightInfo = heightValue > 0 ? ` +${heightValue}cm` : '';
                    const rotationInfo = palletData.rotated ? ' ↻' : '';
                    palletEl.querySelector('.pallet-label').textContent = 
                        `${palletData.finalLength}×${palletData.finalWidth}${rotationInfo}${heightInfo}`;
                    
                    // スタイル更新
                    if (heightValue > 0) {
                        palletEl.classList.add('height-adjusted');
                    } else {
                        palletEl.classList.remove('height-adjusted');
                    }
                    
                    updateStats(containers[elements.containerType.value]);
                    utils.showSuccess(`パレットの高さ調整を${heightValue}cmに設定しました`);
                }
            }

            function deletePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                palletData.deleted = true;
                palletEl.remove();
                updateStats(containers[elements.containerType.value]);
                utils.showSuccess('パレットが削除されました');
            }

            function updatePalletStatus(palletEl) {
                const container = containers[elements.containerType.value];
                const palletData = {
                    x: (parseFloat(palletEl.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (parseFloat(palletEl.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    finalLength: palletEl.clientWidth / renderConfig.scale,
                    finalWidth: palletEl.clientHeight / renderConfig.scale
                };

                const isOutside = isOutsideContainer(palletData, container);
                const hasCollision = checkCollision(palletEl);
                
                palletEl.classList.toggle('outside-container', isOutside);
                palletEl.classList.toggle('colliding', hasCollision);
            }

            function checkCollision(draggedEl) {
                const container = containers[elements.containerType.value];
                const clearance = utils.getCurrentClearance();
                
                const draggedRect = {
                    x: (draggedEl.offsetLeft - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (draggedEl.offsetTop - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    length: draggedEl.clientWidth / renderConfig.scale,
                    width: draggedEl.clientHeight / renderConfig.scale
                };
                
                return allPalletsGenerated.some(p => {
                    if (p.deleted) return false;
                    const el = workArea.querySelector(`[data-pallet-id="${p.id}"][data-instance="${p.instance}"]`);
                    if (el === draggedEl) return false;
                    
                    return rectanglesOverlapWithClearance(
                        draggedRect,
                        { x: p.x, y: p.y, length: p.finalLength, width: p.finalWidth },
                        clearance
                    );
                });
            }

            function updatePalletModel(el) {
                const palletData = allPalletsGenerated.find(p =>
                    p.id == el.dataset.palletId && p.instance == el.dataset.instance
                );
                if (palletData) {
                    palletData.x = (parseFloat(el.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale;
                    palletData.y = (parseFloat(el.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale;
                }
            }
        }

        // 統計更新（高さ調整対応）
        function updateStats(container) {
            const visiblePallets = allPalletsGenerated.filter(p => !p.deleted);
            const insidePallets = visiblePallets.filter(p => !isOutsideContainer(p, container));
            
            const containerArea = (container.length * container.width) / 10000;
            const usedArea = insidePallets.reduce((sum, p) => 
                sum + (p.finalLength * p.finalWidth) / 10000, 0
            );
            
            const totalInputPallets = pallets.reduce((sum, p) => sum + p.qty, 0);
            const totalHeightAdjustment = allPalletsGenerated.reduce((sum, p) => 
                sum + (p.individualHeightAdjustment || 0), 0
            );
            
            document.getElementById('inputPallets').textContent = totalInputPallets;
            document.getElementById('visiblePallets').textContent = visiblePallets.length;
            document.getElementById('loadedPallets').textContent = insidePallets.length;
            document.getElementById('loadingRate').textContent = 
                `${totalInputPallets > 0 ? Math.round((insidePallets.length / totalInputPallets) * 100) : 0}%`;
            document.getElementById('efficiency').textContent = 
                `${containerArea > 0 ? Math.round((usedArea / containerArea) * 100) : 0}%`;
            document.getElementById('remainingArea').textContent = `${(containerArea - usedArea).toFixed(2)}m²`;
            document.getElementById('totalHeightAdjustment').textContent = `${totalHeightAdjustment.toFixed(1)}cm`;
            
            elements.stats.style.display = 'grid';
        }

        function updateLegend() {
            elements.legend.innerHTML = '';
            if (pallets.length === 0) {
                elements.legend.style.display = 'none';
                return;
            }
            
            pallets.forEach(p => {
                const heightInfo = p.heightAdjustment > 0 ? ` (+${p.heightAdjustment}cm)` : '';
                elements.legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${p.color};"></div>
                        <span>${p.length}×${p.width}cm (${p.qty}個)${heightInfo}</span>
                    </div>
                `;
            });
            elements.legend.style.display = 'flex';
        }

        // 画像エクスポート
        function exportLayoutAsImage() {
            const vizArea = document.querySelector('.visualization');
            elements.exportBtn.style.visibility = 'hidden';
            utils.showSuccess('🖼️ 画像を生成中です...');
            
            html2canvas(vizArea, { 
                scale: 2, 
                useCORS: true, 
                backgroundColor: '#ffffff' 
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `container-loading-plan-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                elements.exportBtn.style.visibility = 'visible';
            }).catch(err => {
                console.error('Image export failed:', err);
                utils.showError('画像の生成に失敗しました。');
                elements.exportBtn.style.visibility = 'visible';
            });
        }

        // イベントリスナーの設定
        function setupEventListeners() {
            elements.addPalletBtn.addEventListener('click', () => palletManager.add());
            elements.calculateBtn.addEventListener('click', calculateLoading);
            elements.testBtn.addEventListener('click', runTestCase);
            elements.exportBtn.addEventListener('click', exportLayoutAsImage);
            elements.containerType.addEventListener('change', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.clearanceValue.addEventListener('input', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.heightAdjustment.addEventListener('input', () => {
                updateContainerInfo();
            });
            
            [elements.palletLength, elements.palletWidth, elements.palletQty].forEach(input => {
                input.addEventListener('keypress', e => {
                    if (e.key === 'Enter') palletManager.add();
                });
            });
        }

        function setupPresetButtons() {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.palletLength.value = this.dataset.length;
                    elements.palletWidth.value = this.dataset.width;
                    elements.palletQty.focus();
                });
            });
        }

        // 初期化
        function init() {
            initializeDarkMode();
            setupPresetButtons();
            setupEventListeners();
            updateContainerInfo();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>