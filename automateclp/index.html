<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Automated Container Loader Planeer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<link href="./styles.css" rel="stylesheet"/>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
    font-family: 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', 'Meiryo', sans-serif;
    background: #f8f9fa; /* light mode default */
    color: #2c3e50;
    min-height: 100vh;
    padding: 20px;
    }

    body.dark-mode {
        background: #1a2238; /* dark navy */
        color: #f8f9fa;
    }

    .container {
        max-width: 100%;
        margin: 0 auto;
        background: none;
        border-radius: 0;
        box-shadow: none;
        padding: 0;
    }

    .header {
        background: linear-gradient(135deg, #2c3e50, #34495e);
        color: white;
        padding: 30px;
        text-align: center;
        position: relative;
    }

    .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
    }

    .header p {
        opacity: 0.9;
        font-size: 1.1rem;
    }

    /* === ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« === */
    .header-controls {
        position: absolute;
        top: 20px;
        right: 30px;
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .dark-mode-toggle {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 6px;
        padding: 6px;
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
    }

    .dark-mode-toggle:hover {
        background: rgba(255, 255, 255, 0.2);
        color: white;
    }

    .main-content {
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 0;
        min-height: 700px;
    }

    .sidebar {
        background: none;
        padding: 30px;
        border-right: none;
    }

    .form-group {
        margin-bottom: 25px;
    }

    .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #2c3e50;
    }

    body.dark-mode .form-group label {
        color: #f8f9fa;
    }

    .form-group input,
    .form-group select {
        width: 100%;
        padding: 12px;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.3s ease;
        background: white;
        color: #2c3e50;
    }

    body.dark-mode .form-group input,
    body.dark-mode .form-group select {
        background: #34495e;
        color: #f8f9fa;
        border-color: #495057;
    }

    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .dimensions-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
    }

    .preset-pallets {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        margin-top: 10px;
    }

    .preset-btn {
        padding: 8px 6px;
        background: #e9ecef;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.3s ease;
        font-family: inherit;
        text-align: center;
        line-height: 1.2;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #2c3e50;
    }

    body.dark-mode .preset-btn {
        background: #495057;
        color: #f8f9fa;
    }

    .preset-btn:nth-child(5) {
        grid-column: 1 / -1;
        max-width: 50%;
        margin: 0 auto;
    }

    .preset-btn:hover {
        background: #667eea;
        color: white;
    }

    .add-pallet-btn,
    .calculate-btn,
    .test-btn,
    .export-btn {
        width: 100%;
        padding: 15px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 10px;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 15px;
        font-family: inherit;
    }

    .test-btn {
        background: linear-gradient(135deg, #28a745, #20c997);
    }

    .export-btn {
        background: linear-gradient(135deg, #5bc0de, #337ab7);
    }

    .add-pallet-btn:hover,
    .calculate-btn:hover,
    .test-btn:hover,
    .export-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .pallet-list {
        max-height: 200px;
        overflow-y: auto;
        background: white;
        border-radius: 8px;
        padding: 15px;
        border: 1px solid #e9ecef;
    }

    body.dark-mode .pallet-list {
        background: #34495e;
        border-color: #495057;
    }

    .pallet-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        margin-bottom: 8px;
        background: #f8f9fa;
        border-radius: 6px;
        font-size: 14px;
        color: #2c3e50;
    }

    body.dark-mode .pallet-item {
        background: #495057;
        color: #f8f9fa;
    }

    .pallet-item .remove-btn {
        background: #dc3545;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 12px;
    }

    .visualization {
        padding: 30px;
        background: none;
    }

    .container-view {
        background: none;
        border-radius: 0;
        padding: 0;
        margin-bottom: 0;
        position: relative;
        overflow: visible;
        min-height: 400px;
    }

    .work-area {
        position: relative;
        width: 100%;
        min-height: 400px;
        overflow: visible;
    }

    .container-floor {
        background: #e9ecef;
        border: 3px solid #e74c3c;
        border-radius: 8px;
        position: absolute;
        left: 0;
        top: 0;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        width: 600px;
        height: 300px;
    }

    body.dark-mode .container-floor {
        background: #34495e;
    }

    .container-floor::before {
        content: '';
        position: absolute;
        top: -1px;
        left: -1px;
        right: -1px;
        bottom: -1px;
        border: 1px solid rgba(231, 76, 60, 0.5);
        pointer-events: none;
    }

    .pallet-2d {
        position: absolute;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        box-shadow: 0 0 0 5px rgba(255, 255, 255, 0.1);
        touch-action: none;
        transition: box-shadow 0.2s ease, background 0.2s ease;
    }

    .pallet-2d:hover {
        filter: brightness(1.2);
        z-index: 10;
    }
    
    /* 3Dç©ã¿é‡ã­è¡¨ç¤ºç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
    .pallet-2d.stacked {
        border: 2px solid #e74c3c;
        box-shadow: 0 2px 8px rgba(231, 76, 60, 0.3);
    }
    
    .pallet-2d.base-pallet {
        border: 2px solid #27ae60;
        box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }

    .pallet-2d.dragging {
        cursor: grabbing;
        z-index: 1000;
        opacity: 0.8;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
    }

    .pallet-2d.colliding {
        box-shadow: 0 0 0 4px rgba(255, 20, 20, 0.8) !important;
    }

    .pallet-2d.outside-container {
        border-color: rgba(231, 76, 60, 0.9) !important;
        box-shadow: 0 0 0 3px rgba(231, 76, 60, 0.6) !important;
        opacity: 0.9;
    }

    .pallet-2d.bottom-placed {
        opacity: 0.9;
        border-color: rgba(108, 117, 125, 0.8);
        box-shadow: 0 0 0 2px rgba(108, 117, 125, 0.4);
    }

    .pallet-2d.deleted {
        opacity: 0.3;
        filter: grayscale(100%);
        pointer-events: none;
    }

    .pallet-label {
        font-size: 10px;
        font-weight: bold;
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        pointer-events: none;
        text-align: center;
        line-height: 1.2;
        padding: 0 5px;
        box-sizing: border-box;
    }

    .pallet-controls {
        position: absolute;
        top: 2px;
        right: 2px;
        display: flex;
        gap: 2px;
        z-index: 100;
    }

    .rotate-btn,
    .delete-btn {
        width: 20px;
        height: 20px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        color: white;
        cursor: pointer;
        transition: background 0.2s ease;
        pointer-events: auto;
        border: none;
    }

    .rotate-btn:hover {
        background: rgba(0, 100, 200, 0.8);
    }

    .delete-btn:hover {
        background: rgba(220, 53, 69, 0.8);
    }

    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 15px;
        margin-top: 30px;
    }

    .stat-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        padding: 18px;
        border-radius: 12px;
        text-align: center;
        min-height: 80px;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .stat-value {
        font-size: 2rem;
        font-weight: bold;
        margin-bottom: 5px;
    }

    .stat-label {
        opacity: 0.9;
        font-size: 14px;
    }

    .loading-animation {
        display: none;
        text-align: center;
        padding: 40px;
    }

    .spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .error-message {
        background: #f8d7da;
        color: #721c24;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
    }

    body.dark-mode .error-message {
        background: #721c24;
        color: #f8d7da;
    }

    .success-message {
        background: #d1edff;
        color: #0c5460;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
    }

    body.dark-mode .success-message {
        background: #0c5460;
        color: #d1edff;
    }

    .container-info {
        background: #e9ecef;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 500;
        color: #2c3e50;
    }

    body.dark-mode .container-info {
        background: #34495e;
        color: #f8f9fa;
    }

    .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 8px;
    }

    body.dark-mode .legend {
        background: #34495e;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        color: #2c3e50;
    }

    body.dark-mode .legend-item {
        color: #f8f9fa;
    }

    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .manual-instructions {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
        font-size: 14px;
        color: #856404;
    }

    body.dark-mode .manual-instructions {
        background: #4a3b1a;
        border-color: #856404;
        color: #fff3cd;
    }

    .manual-instructions h4 {
        margin-bottom: 8px;
        color: #856404;
    }

    body.dark-mode .manual-instructions h4 {
        color: #fff3cd;
    }

    .manual-instructions ul {
        margin-left: 20px;
    }

    .unloaded-summary {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }

    body.dark-mode .unloaded-summary {
        background: #4a3b1a;
        border-color: #856404;
    }

    .unloaded-summary h4 {
        color: #856404;
        margin-bottom: 10px;
        font-size: 14px;
    }

    body.dark-mode .unloaded-summary h4 {
        color: #fff3cd;
    }

    .unloaded-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 12px;
        margin-bottom: 5px;
        background: rgba(255, 193, 7, 0.1);
        border-radius: 4px;
        font-size: 13px;
        color: #856404;
    }

    body.dark-mode .unloaded-item {
        background: rgba(255, 193, 7, 0.2);
        color: #fff3cd;
    }
</style>

</head>
<body>
<div class="container">
<div class="header">
<div class="header-controls">
<button class="dark-mode-toggle" id="darkModeToggle" title="ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ">
ğŸŒ™
</button>
</div>
<h1>Auto CLP - ã‚³ãƒ³ãƒ†ãƒŠãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼</h1>
<p>ãƒ‘ãƒ¬ãƒƒãƒˆæƒ…å ±ã¨æšæ•°ã‚’å…¥åŠ›â†’ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§è‡ªå‹•é…ç½®</p>
</div>
<div class="main-content">
<div class="sidebar">
<div class="form-group">
<label for="containerType">ã‚³ãƒ³ãƒ†ãƒŠã‚¿ã‚¤ãƒ—</label>
        <select id="containerType">
        <option value="20ft">20ftã‚³ãƒ³ãƒ†ãƒŠ (5.898m Ã— 2.352m Ã— 2.385m å†…å¯¸)</option>
        <option value="40ft">40ftã‚³ãƒ³ãƒ†ãƒŠ (12.032m Ã— 2.350m Ã— 2.385m å†…å¯¸)</option>
        <option value="40HQ">40HQã‚³ãƒ³ãƒ†ãƒŠ (12.032m Ã— 2.350m Ã— 2.690m å†…å¯¸)</option>
                </select>
        </div>
        <div class="form-group">
        <label>
        <input type="checkbox" id="enableStacking" style="margin-right: 8px; width: auto;">
        ãƒ‘ãƒ¬ãƒƒãƒˆç©ã¿é‡ã­ã‚’æœ‰åŠ¹ã«ã™ã‚‹
        </label>
        <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
        ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã¨ã€ãƒ‘ãƒ¬ãƒƒãƒˆã‚’3Dã§ç©ã¿é‡ã­ã¦é…ç½®ã—ã¾ã™ï¼ˆé‡é‡ã¨é‡å¿ƒã‚’è€ƒæ…®ï¼‰
        </small>
        </div>
        <div class="form-group">
        <label>ãƒ‘ãƒ¬ãƒƒãƒˆå¯¸æ³• (cm)</label>
        <div class="dimensions-grid">
        <input id="palletLength" max="300" min="1" placeholder="é•·ã•" type="number"/>
        <input id="palletWidth" max="300" min="1" placeholder="å¹…" type="number"/>
        </div>
        <div class="dimensions-grid" style="margin-top: 10px;">
        <input id="palletHeight" max="300" min="1" placeholder="é«˜ã•" type="number"/>
        <input id="palletWeight" max="2000" min="1" placeholder="é‡é‡(kg)" type="number"/>
        </div>
        <div class="form-group" style="margin-top: 15px;">
        <label style="margin-bottom: 10px;">ç©ã¿é‡ã­åˆ¶ç´„</label>
        <div style="display: flex; gap: 15px; align-items: center;">
        <label style="display: flex; align-items: center; font-weight: normal; font-size: 14px;">
        <input type="checkbox" id="canStackAbove" checked style="margin-right: 6px; width: auto;">
        ä»–ã®ãƒ‘ãƒ¬ãƒƒãƒˆã®ä¸Šã«ç©ã‚ã‚‹
        </label>
        <label style="display: flex; align-items: center; font-weight: normal; font-size: 14px;">
        <input type="checkbox" id="canStackBelow" checked style="margin-right: 6px; width: auto;">
        ä»–ã®ãƒ‘ãƒ¬ãƒƒãƒˆã®ä¸‹ã«ç©ã¾ã‚Œã‚‹
        </label>
        </div>
        <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
        ä¸¡æ–¹ãƒã‚§ãƒƒã‚¯è§£é™¤ã™ã‚‹ã¨ç©ã¿é‡ã­ä¸å¯ã€ç‰‡æ–¹ã®ã¿ã§åˆ¶é™ä»˜ãç©ã¿é‡ã­
        </small>
        </div>
        <div class="preset-pallets">
        <button class="preset-btn" data-length="120" data-width="100" data-height="120" data-weight="600" type="button">
                            EUR<br/>(120Ã—100Ã—120)
                        </button>
        <button class="preset-btn" data-length="120" data-width="80" data-height="100" data-weight="400" type="button">
                            EUR2<br/>(120Ã—80Ã—100)
                        </button>
        <button class="preset-btn" data-length="122" data-width="102" data-height="120" data-weight="700" type="button">
                            US<br/>(122Ã—102Ã—120)
                        </button>
        <button class="preset-btn" data-length="110" data-width="110" data-height="120" data-weight="500" type="button">
                            æ­£æ–¹å½¢<br/>(110Ã—110Ã—120)
                        </button>
        <button class="preset-btn" data-length="100" data-width="125" data-height="100" data-weight="600" type="button">
                            ã‚«ã‚¹ã‚¿ãƒ <br/>(100Ã—125Ã—100)
                        </button>
        </div>
</div>
<div class="form-group">
<label for="palletQty">æ•°é‡</label>
<input id="palletQty" max="100" min="1" placeholder="ãƒ‘ãƒ¬ãƒƒãƒˆæ•°" type="number" value="1"/>
</div>
<div class="form-group">
<label for="clearanceValue">ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ (cm)</label>
<input id="clearanceValue" max="15" min="1" placeholder="ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹" step="0.5" type="number" value="1"/>
<small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
ãƒ‘ãƒ¬ãƒƒãƒˆé–“ã®æœ€å°é–“éš”ã‚’è¨­å®šï¼ˆ0.5cmåˆ»ã¿èª¿æ•´å¯èƒ½ï¼‰<br/>
<strong>â€»è¨ˆç®—æ™‚ã«é©ç”¨ã•ã‚Œã¾ã™ï¼ˆ0=éš™é–“ãªã—é…ç½®ã§æœ€å¤§ç©è¼‰ï¼‰</strong>
</small>
</div>
<button class="add-pallet-btn" id="addPalletBtn" type="button">â• ãƒ‘ãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ </button>
<div class="form-group">
<label>ãƒ‘ãƒ¬ãƒƒãƒˆãƒªã‚¹ãƒˆ</label>
<div class="pallet-list" id="palletList">
<p style="text-align: center; color: #6c757d; font-style: italic;">ãƒ‘ãƒ¬ãƒƒãƒˆãŒã¾ã è¿½åŠ ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>
</div>
</div>
        <button class="test-btn" id="testBtn" type="button">ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å®Ÿè¡Œ</button>
        <button class="calculate-btn" id="calculateBtn" type="button">ğŸ”„ ç©è¼‰ãƒ—ãƒ©ãƒ³ã‚’è¨ˆç®—</button>
        <div class="form-group" style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef;">
        <label style="margin-bottom: 10px; color: #495057;">ğŸ› ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½</label>
        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <button type="button" id="debugStacking" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">ç©ã¿é‡ã­ãƒ†ã‚¹ãƒˆ</button>
        <button type="button" id="debugGravity" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">é‡å¿ƒè¨ˆç®—ãƒ†ã‚¹ãƒˆ</button>
        <button type="button" id="debugLayout" style="padding: 8px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè§£æ</button>
        <button type="button" id="debugClear" style="padding: 8px 12px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">ãƒ‡ãƒãƒƒã‚°ã‚¯ãƒªã‚¢</button>
        </div>
        <div id="debugOutput" style="margin-top: 10px; padding: 8px; background: white; border-radius: 4px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto; display: none;"></div>
        </div>
<button class="export-btn" id="exportBtn" style="display: none;" type="button">ğŸ–¼ï¸ é…ç½®å›³ã‚’ç”»åƒã§ä¿å­˜</button>
</div>
<div class="visualization">
<div class="error-message" id="errorMessage"></div>
<div class="success-message" id="successMessage"></div>
<div class="container-info" id="containerInfo">
                    ã‚³ãƒ³ãƒ†ãƒŠã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„
                </div>
<div class="loading-animation" id="loadingAnimation">
<div class="spinner"></div>
<p>æœ€é©ãªç©è¼‰ãƒ—ãƒ©ãƒ³ã‚’è¨ˆç®—ä¸­...</p>
</div>
                <div class="manual-instructions" id="manualInstructions" style="display: none;">
<h4>ğŸ“‹ ãƒãƒ‹ãƒ¥ã‚¢ãƒ«èª¿æ•´ã‚¬ã‚¤ãƒ‰</h4>
<ul>
<li>ğŸ–±ï¸ ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è‡ªç”±ã«ä½ç½®èª¿æ•´</li>
<li>â†» å›è»¢ãƒœã‚¿ãƒ³ã§å‘ãã‚’å¤‰æ›´</li>
<li>ğŸ—‘ï¸ å‰Šé™¤ãƒœã‚¿ãƒ³ã§ä¸è¦ãªãƒ‘ãƒ¬ãƒƒãƒˆã‚’é™¤å»</li>
<li>ğŸ”´ èµ¤ã„æ ç·šã¯ã‚³ãƒ³ãƒ†ãƒŠæ å¤–é…ç½®ã‚’ç¤ºã—ã¾ã™</li>
<li>ğŸ“¦ ã‚°ãƒ¬ãƒ¼æ ç·šã¯ä¸‹å´é…ç½®ï¼ˆè‡ªå‹•ã§é…ç½®ã•ã‚ŒãŸã‚‚ã®ï¼‰</li>
<li>ğŸ”„ åŒã˜ã‚µã‚¤ã‚ºã§ã‚‚å€‹åˆ¥ã«å‘ãã‚’å¤‰æ›´å¯èƒ½</li>
<li>âœ¨ å¢ƒç•Œåˆ¶é™ãªã—ï¼šã‚³ãƒ³ãƒ†ãƒŠæ ç·šã´ã£ãŸã‚Šã¾ã§é…ç½®å¯èƒ½</li>
</ul>
</div>
<div class="legend" id="legend" style="display: none;">
</div>
<div class="unloaded-summary" id="unloadedSummary" style="display: none;"></div>
<div class="container-view">
<div class="work-area">
<div class="container-floor" id="containerFloor">
</div>
</div>
</div>
<div class="stats" id="stats" style="display: none;">
<div class="stat-card">
<div class="stat-value" id="inputPallets">0</div>
<div class="stat-label">å…¥åŠ›ãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
</div>
<div class="stat-card">
<div class="stat-value" id="visiblePallets">0</div>
<div class="stat-label">è¡¨ç¤ºãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
</div>
<div class="stat-card">
<div class="stat-value" id="loadedPallets">0</div>
<div class="stat-label">æ å†…ãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
</div>
<div class="stat-card">
<div class="stat-value" id="loadingRate">0%</div>
<div class="stat-label">ç©è¼‰ç‡</div>
</div>
<div class="stat-card">
<div class="stat-value" id="efficiency">0%</div>
<div class="stat-label">åºŠé¢åŠ¹ç‡</div>
</div>
<div class="stat-card">
<div class="stat-value" id="remainingArea">0mÂ²</div>
<div class="stat-label">æ®‹ã‚ŠåºŠé¢ç©</div>
</div>
</div>
</div>
</div>
</div>
<script src="./app.js"></script>
<!-- externalized JS loaded; removed inline script -->
        

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let pallets = [];
        let allPalletsGenerated = [];
        let renderConfig = {
            scale: 1,
            containerOffset: { x: CONSTANTS.CONTAINER_OFFSET_X, y: CONSTANTS.CONTAINER_OFFSET_Y },
            containerBounds: null
        };

        const containers = {
            '20ft': { length: 589.8, width: 235.2, height: 238.5 },
            '40ft': { length: 1203.2, width: 235.0, height: 238.5 },
            '40HQ': { length: 1203.2, width: 235.0, height: 269.0 }
        };

        // DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const elements = {
            containerType: document.getElementById('containerType'),
            enableStacking: document.getElementById('enableStacking'),
            palletLength: document.getElementById('palletLength'),
            palletWidth: document.getElementById('palletWidth'),
            palletHeight: document.getElementById('palletHeight'),
            palletWeight: document.getElementById('palletWeight'),
            canStackAbove: document.getElementById('canStackAbove'),
            canStackBelow: document.getElementById('canStackBelow'),
            palletQty: document.getElementById('palletQty'),
            clearanceValue: document.getElementById('clearanceValue'),
            addPalletBtn: document.getElementById('addPalletBtn'),
            calculateBtn: document.getElementById('calculateBtn'),
            testBtn: document.getElementById('testBtn'),
            exportBtn: document.getElementById('exportBtn'),
            palletList: document.getElementById('palletList'),
            containerInfo: document.getElementById('containerInfo'),
            loadingAnimation: document.getElementById('loadingAnimation'),
            manualInstructions: document.getElementById('manualInstructions'),
            legend: document.getElementById('legend'),
            unloadedSummary: document.getElementById('unloadedSummary'),
            containerFloor: document.getElementById('containerFloor'),
            stats: document.getElementById('stats'),
            errorMessage: document.getElementById('errorMessage'),
            successMessage: document.getElementById('successMessage'),
            darkModeToggle: document.getElementById('darkModeToggle'),
            debugOutput: document.getElementById('debugOutput')
        };

        // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆæœŸåŒ–
        function initDarkMode() {
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                elements.darkModeToggle.textContent = 'â˜€ï¸';
            } else {
                elements.darkModeToggle.textContent = 'ğŸŒ™';
            }

            elements.darkModeToggle.addEventListener('click', () => {
                document.body.classList.toggle('dark-mode');
                const isDark = document.body.classList.contains('dark-mode');
                localStorage.setItem('darkMode', isDark);
                elements.darkModeToggle.textContent = isDark ? 'â˜€ï¸' : 'ğŸŒ™';
            });
        }

        // ãƒ¡ãƒ¢ãƒªç®¡ç†ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
        const memoryManager = {
            // ã‚¿ã‚¤ãƒãƒ¼ã®è¿½è·¡
            timers: new Set(),
            
            // å®‰å…¨ãªã‚¿ã‚¤ãƒãƒ¼è¨­å®š
            setTimeout: (callback, delay) => {
                const timerId = setTimeout(callback, delay);
                memoryManager.timers.add(timerId);
                return timerId;
            },
            
            // ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¯ãƒªã‚¢
            clearTimeout: (timerId) => {
                clearTimeout(timerId);
                memoryManager.timers.delete(timerId);
            },
            
            // å…¨ã‚¿ã‚¤ãƒãƒ¼ã®ã‚¯ãƒªã‚¢
            clearAllTimers: () => {
                memoryManager.timers.forEach(timerId => {
                    clearTimeout(timerId);
                });
                memoryManager.timers.clear();
            },
            
            // ãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
            cleanup: () => {
                memoryManager.clearAllTimers();
                
                // å¤§ããªãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®ã‚¯ãƒªã‚¢
                if (window.allPalletsGenerated && window.allPalletsGenerated.length > 1000) {
                    console.log('Large dataset detected, clearing old data...');
                    window.allPalletsGenerated = window.allPalletsGenerated.slice(-500);
                }
                
                // æœªä½¿ç”¨ã®DOMè¦ç´ ã®ã‚¯ãƒªã‚¢
                const unusedElements = document.querySelectorAll('.temp-element, .calculation-result');
                if (unusedElements.length > 50) {
                    console.log('Clearing unused DOM elements...');
                    unusedElements.forEach(el => el.remove());
                }
            }
        };

        // ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
        const debug = {
            log: function(message, data = null) {
                const timestamp = new Date().toLocaleTimeString();
                let logMessage = `[${timestamp}] ${message}`;
                
                if (data) {
                    if (typeof data === 'object') {
                        logMessage += '\n' + JSON.stringify(data, null, 2);
                    } else {
                        logMessage += `: ${data}`;
                    }
                }
                
                console.log(logMessage);
                
                // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ã‚¨ãƒªã‚¢ã«è¡¨ç¤º
                if (elements.debugOutput) {
                    elements.debugOutput.style.display = 'block';
                    elements.debugOutput.innerHTML += `<div style="margin-bottom: 5px; border-bottom: 1px solid #eee; padding-bottom: 3px;">${logMessage.replace(/\n/g, '<br>')}</div>`;
                    elements.debugOutput.scrollTop = elements.debugOutput.scrollHeight;
                }
            },
            
            clear: function() {
                if (elements.debugOutput) {
                    elements.debugOutput.innerHTML = '';
                    elements.debugOutput.style.display = 'none';
                }
                console.clear();
            },
            
            testStacking: function() {
                this.log('=== ç©ã¿é‡ã­ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
                this.log('ãƒ‘ãƒ¬ãƒƒãƒˆæ•°:', pallets.length);
                this.log('ç©ã¿é‡ã­æœ‰åŠ¹:', elements.enableStacking.checked);
                
                pallets.forEach((pallet, index) => {
                    this.log(`ãƒ‘ãƒ¬ãƒƒãƒˆ#${pallet.palletNumber}:`, {
                        size: `${pallet.length}Ã—${pallet.width}Ã—${pallet.height}cm`,
                        weight: `${pallet.weight}kg`,
                        stacking: `${pallet.canStackAbove ? 'ä¸Šç©ã¿å¯' : 'ä¸Šç©ã¿ä¸å¯'}, ${pallet.canStackBelow ? 'ä¸‹ç©ã¿å¯' : 'ä¸‹ç©ã¿ä¸å¯'}`
                    });
                });
                
                if (allPalletsGenerated.length > 0) {
                    this.log('ç”Ÿæˆæ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆæ•°:', allPalletsGenerated.length);
                    this.log('é…ç½®æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆæ•°:', allPalletsGenerated.filter(p => p.placed).length);
                    this.log('ç©ã¿é‡ã­æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆæ•°:', allPalletsGenerated.filter(p => p.stackedOn).length);
                }
            },
            
            testGravity: function() {
                this.log('=== é‡å¿ƒè¨ˆç®—ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
                
                if (allPalletsGenerated.length === 0) {
                    this.log('ãƒ‘ãƒ¬ãƒƒãƒˆãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const placedPallets = allPalletsGenerated.filter(p => p.placed && !p.deleted);
                if (placedPallets.length === 0) {
                    this.log('é…ç½®æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“');
                    return;
                }
                
                const stability = calculateStackingStability(placedPallets);
                this.log('é‡å¿ƒè¨ˆç®—çµæœ:', stability);
                
                // å„ãƒ‘ãƒ¬ãƒƒãƒˆã®è©³ç´°æƒ…å ±
                placedPallets.forEach(pallet => {
                    this.log(`ãƒ‘ãƒ¬ãƒƒãƒˆ#${pallet.palletNumber}:`, {
                        position: `(${pallet.x}, ${pallet.y}, ${pallet.z})`,
                        size: `${pallet.finalLength}Ã—${pallet.finalWidth}Ã—${pallet.finalHeight}cm`,
                        weight: `${pallet.weight}kg`,
                        stackedOn: pallet.stackedOn ? `#${pallet.stackedOn.palletNumber}` : 'ãªã—',
                        stackedBy: pallet.stackedBy.length > 0 ? pallet.stackedBy.map(s => `#${s.palletNumber}`).join(', ') : 'ãªã—'
                    });
                });
            },
            
            testLayout: function() {
                this.log('=== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè§£æãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
                
                const container = containers[elements.containerType.value];
                this.log('ã‚³ãƒ³ãƒ†ãƒŠæƒ…å ±:', {
                    type: elements.containerType.value,
                    dimensions: `${container.length}Ã—${container.width}Ã—${container.height}cm`,
                    clearance: `${utils.getCurrentClearance()}cm`
                });
                
                if (allPalletsGenerated.length === 0) {
                    this.log('ãƒ‘ãƒ¬ãƒƒãƒˆãŒé…ç½®ã•ã‚Œã¦ã„ã¾ã›ã‚“');
                    return;
                }
                
                const placedPallets = allPalletsGenerated.filter(p => p.placed && !p.deleted);
                const unplacedPallets = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
                
                this.log('é…ç½®çŠ¶æ³:', {
                    total: allPalletsGenerated.length,
                    placed: placedPallets.length,
                    unplaced: unplacedPallets.length,
                    deleted: allPalletsGenerated.filter(p => p.deleted).length
                });
                
                // é¢ç©ä½¿ç”¨ç‡è¨ˆç®—
                const totalArea = container.length * container.width;
                const usedArea = placedPallets.reduce((sum, p) => sum + (p.finalLength * p.finalWidth), 0);
                const areaUtilization = (usedArea / totalArea) * 100;
                
                this.log('é¢ç©ä½¿ç”¨ç‡:', `${areaUtilization.toFixed(2)}%`);
                
                // é«˜ã•ä½¿ç”¨ç‡è¨ˆç®—ï¼ˆç©ã¿é‡ã­æ™‚ï¼‰
                if (elements.enableStacking.checked) {
                    const maxHeight = Math.max(...placedPallets.map(p => p.z + p.finalHeight));
                    const heightUtilization = (maxHeight / container.height) * 100;
                    this.log('é«˜ã•ä½¿ç”¨ç‡:', `${heightUtilization.toFixed(2)}%`);
                }
                
                // é‡é‡åˆ†å¸ƒ
                const totalWeight = placedPallets.reduce((sum, p) => sum + (p.weight || 0), 0);
                this.log('ç·é‡é‡:', `${totalWeight}kg`);
            }
        };
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ‡ãƒãƒƒã‚°é–¢æ•°
        function debugLog(message, data = null) {
            debug.log(message, data);
        }
        
        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        const utils = {
            getCurrentClearance: () => parseFloat(elements.clearanceValue.value) || 1,
            getRandomColor: () => {
                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            showError: (message) => {
                elements.errorMessage.textContent = message;
                elements.errorMessage.style.display = 'block';
                // å®‰å…¨ãªã‚¿ã‚¤ãƒãƒ¼ä½¿ç”¨
                const timerId = memoryManager.setTimeout(() => {
                    elements.errorMessage.style.display = 'none';
                }, 5000);
            },
            showSuccess: (message) => {
                elements.successMessage.textContent = message;
                elements.successMessage.style.display = 'block';
                // å®‰å…¨ãªã‚¿ã‚¤ãƒãƒ¼ä½¿ç”¨
                const timerId = memoryManager.setTimeout(() => {
                    elements.successMessage.style.display = 'none';
                }, 5000);
            },
            adjustColor: (color, amount) => {
                return '#' + color.replace(/^#/, '').replace(/../g, value => 
                    ('0' + Math.min(255, Math.max(0, parseInt(value, 16) + amount)).toString(16)).substr(-2)
                );
            },
            calculateScale: (container) => {
                const scaleX = CONSTANTS.CONTAINER_DISPLAY_WIDTH / container.length;
                const scaleY = CONSTANTS.CONTAINER_DISPLAY_HEIGHT / container.width;
                return Math.min(scaleX, scaleY);
            }
        };

        // ãƒ‘ãƒ¬ãƒƒãƒˆç®¡ç†
        const palletManager = {
            add: function() {
                const length = parseInt(elements.palletLength.value);
                const width = parseInt(elements.palletWidth.value);
                const height = parseInt(elements.palletHeight.value) || 0;
                const weight = parseInt(elements.palletWeight.value) || 0;
                const qty = parseInt(elements.palletQty.value);
                const canStackAbove = elements.canStackAbove.checked;
                const canStackBelow = elements.canStackBelow.checked;
                
                if (!this.validate(length, width, height, weight, qty)) return;
                
                // ãƒ‘ãƒ¬ãƒƒãƒˆç•ªå·ã‚’è‡ªå‹•ç”Ÿæˆ
                const palletNumber = this.generatePalletNumber();
                
                pallets.push({
                    id: Date.now(),
                    palletNumber: palletNumber,
                    length,
                    width,
                    height,
                    weight,
                    qty,
                    canStackAbove,
                    canStackBelow,
                    color: utils.getRandomColor()
                });
                
                updatePalletList();
                updateContainerInfo();
                clearInputs();
                clearResults();
            },
            
            generatePalletNumber: function() {
                // æ—¢å­˜ã®ãƒ‘ãƒ¬ãƒƒãƒˆç•ªå·ã‚’å–å¾—ã—ã¦æ¬¡ã®ç•ªå·ã‚’ç”Ÿæˆ
                const existingNumbers = pallets.map(p => p.palletNumber);
                let nextNumber = 1;
                while (existingNumbers.includes(nextNumber)) {
                    nextNumber++;
                }
                return nextNumber;
            },
            
            validate: (length, width, height, weight, qty) => {
                if (!length || !width || !qty || length <= 0 || width <= 0 || qty <= 0) {
                    utils.showError('æœ‰åŠ¹ãªãƒ‘ãƒ¬ãƒƒãƒˆå¯¸æ³•ã¨æ•°é‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return false;
                }
                if (length > 300 || width > 300 || height > 300) {
                    utils.showError('ãƒ‘ãƒ¬ãƒƒãƒˆã‚µã‚¤ã‚ºã¯300cmä»¥ä¸‹ã«ã—ã¦ãã ã•ã„');
                    return false;
                }
                if (weight > 2000) {
                    utils.showError('ãƒ‘ãƒ¬ãƒƒãƒˆé‡é‡ã¯2000kgä»¥ä¸‹ã«ã—ã¦ãã ã•ã„');
                    return false;
                }
                if (qty > 100) {
                    utils.showError('ãƒ‘ãƒ¬ãƒƒãƒˆæ•°é‡ã¯100å€‹ä»¥ä¸‹ã«ã—ã¦ãã ã•ã„');
                    return false;
                }
                return true;
            },
            
            remove: (id) => {
                pallets = pallets.filter(p => p.id !== id);
                updatePalletList();
                updateContainerInfo();
                clearResults();
            }
        };

        // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        function runTestCase() {
            pallets = [];
            allPalletsGenerated = [];
            elements.containerType.value = '40ft';
            elements.clearanceValue.value = '1';
            elements.enableStacking.checked = true;
            
            const testData = [
                { l: 110, w: 110, h: 120, wt: 800, q: 12, c: '#f39c12', above: true, below: true },  // é»„è‰²
                { l: 100, w: 125, h: 100, wt: 600, q: 8, c: '#3498db', above: true, below: true }    // é’è‰²
            ];
            
            testData.forEach((p, i) => pallets.push({
                id: Date.now() + i,
                palletNumber: i + 1,
                length: p.l,
                width: p.w,
                height: p.h,
                weight: p.wt,
                qty: p.q,
                canStackAbove: p.above,
                canStackBelow: p.below,
                color: p.c
            }));
            
            updatePalletList();
            updateContainerInfo();
            clearResults();
            utils.showSuccess('ğŸ¯ 3Dç©ã¿é‡ã­ãƒ†ã‚¹ãƒˆ: 110Ã—110Ã—120cm (12å€‹) + 100Ã—125Ã—100cm (8å€‹)');
        }

        // UIæ›´æ–°é–¢æ•°
        function updatePalletList() {
            elements.palletList.innerHTML = '';
            
            if (pallets.length === 0) {
                elements.palletList.innerHTML = '<p style="text-align:center;color:#6c757d;font-style:italic;">ãƒ‘ãƒ¬ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
                    pallets.forEach(p => {
            const item = document.createElement('div');
            item.className = 'pallet-item';
            const stackInfo = p.canStackAbove && p.canStackBelow ? 'ç©ã¿é‡ã­å¯' : 
                             p.canStackAbove ? 'ä¸Šç©ã¿ã®ã¿' : 
                             p.canStackBelow ? 'ä¸‹ç©ã¿ã®ã¿' : 'ç©ã¿é‡ã­ä¸å¯';
            const weightInfo = p.weight > 0 ? ` ${p.weight}kg` : '';
            const heightInfo = p.height > 0 ? ` H:${p.height}cm` : '';
            item.innerHTML = `
                <div style="flex: 1;">
                    <div style="font-weight: bold;">#${p.palletNumber} ${p.length}Ã—${p.width}${heightInfo}${weightInfo}</div>
                    <div style="font-size: 12px; color: #6c757d;">${p.qty}å€‹ - ${stackInfo}</div>
                </div>
                <button class="remove-btn">âœ•</button>
            `;
            item.querySelector('.remove-btn').addEventListener('click', () => palletManager.remove(p.id));
            elements.palletList.appendChild(item);
        });
        }

        function updateContainerInfo() {
            const container = containers[elements.containerType.value];
            elements.containerInfo.innerHTML = `${elements.containerType.value}å†…å¯¸: ${(container.length/100).toFixed(3)}mÃ—${(container.width/100).toFixed(3)}mÃ—${(container.height/100).toFixed(3)}m <small>ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹: ${utils.getCurrentClearance()}cm</small>`;
        }

        function clearInputs() {
            elements.palletLength.value = '';
            elements.palletWidth.value = '';
            elements.palletHeight.value = '';
            elements.palletWeight.value = '';
            elements.palletQty.value = '1';
            elements.canStackAbove.checked = true;
            elements.canStackBelow.checked = true;
        }

        function clearResults() {
            allPalletsGenerated = [];
            const workArea = elements.containerFloor.parentElement;
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
            const container = containers[elements.containerType.value];
            renderConfig.scale = utils.calculateScale(container);
            
            elements.containerFloor.style.width = `${container.length * renderConfig.scale}px`;
            elements.containerFloor.style.height = `${container.width * renderConfig.scale}px`;
            elements.containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            elements.containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            ['stats', 'legend', 'unloadedSummary', 'exportBtn', 'manualInstructions'].forEach(id => {
                elements[id].style.display = 'none';
            });
        }

        // é…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é–¢é€£
        function canPlace2D(x, y, length, width, placed, clearance, container = null) {
            const rect1 = { x, y, length, width };
            const cont = container || containers[elements.containerType.value];
            
            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            if (x < 0 || y < 0 || x + length > cont.length || y + width > cont.width) {
                return false;
            }
            
            // è¡çªãƒã‚§ãƒƒã‚¯
            return !placed.some(rect2 => rectanglesOverlapWithClearance(rect1, rect2, clearance));
        }

        function rectanglesOverlapWithClearance(r1, r2, clearance) {
            return !(
                r1.x + r1.length + clearance <= r2.x + CONSTANTS.EPSILON ||
                r2.x + r2.length + clearance <= r1.x + CONSTANTS.EPSILON ||
                r1.y + r1.width + clearance <= r2.y + CONSTANTS.EPSILON ||
                r2.y + r2.width + clearance <= r1.y + CONSTANTS.EPSILON
            );
        }
        function calculateLoading() {
            if (pallets.length === 0) {
                return utils.showError('å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã—ã¦ãã ã•ã„');
            }
            
            const container = containers[elements.containerType.value];
            const clearance = utils.getCurrentClearance();
            elements.loadingAnimation.style.display = 'block';
            elements.exportBtn.style.display = 'none';

            setTimeout(() => {
                allPalletsGenerated = [];
                
                // å…¨ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆ
                pallets.forEach(pt => {
                    for (let i = 0; i < pt.qty; i++) {
                        allPalletsGenerated.push({
                            id: pt.id,
                            instance: i,
                            palletNumber: pt.palletNumber,
                            length: pt.length,
                            width: pt.width,
                            height: pt.height || 0,
                            weight: pt.weight || 0,
                            canStackAbove: pt.canStackAbove,
                            canStackBelow: pt.canStackBelow,
                            color: pt.color,
                            placed: false,
                            deleted: false,
                            x: 0,
                            y: 0,
                            z: 0, // 3Dåº§æ¨™
                            finalLength: pt.length,
                            finalWidth: pt.width,
                            finalHeight: pt.height || 0,
                            rotated: false,
                            stackedOn: null, // ç©ã¿é‡ã­å…ˆã®ãƒ‘ãƒ¬ãƒƒãƒˆID
                            stackedBy: [] // ã“ã®ãƒ‘ãƒ¬ãƒƒãƒˆã®ä¸Šã«ç©ã¾ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¬ãƒƒãƒˆID
                        });
                    }
                });
                
                console.log(`ç”Ÿæˆã•ã‚ŒãŸãƒ‘ãƒ¬ãƒƒãƒˆæ•°: ${allPalletsGenerated.length}`);
                console.log(`ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚º: ${container.length}cm Ã— ${container.width}cm`);
                console.log(`ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹: ${clearance}cm`);
                
                // è‡ªå‹•é…ç½®
                packPallets2D(allPalletsGenerated.filter(p => !p.deleted), container, clearance);
                
                // é…ç½®æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ä¸­å¤®ã«ç§»å‹•
                const placedPallets = allPalletsGenerated.filter(p => p.placed);
                if (placedPallets.length > 0) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    placedPallets.forEach(p => {
                        minX = Math.min(minX, p.x);
                        minY = Math.min(minY, p.y);
                        maxX = Math.max(maxX, p.x + p.finalLength);
                        maxY = Math.max(maxY, p.y + p.finalWidth);
                    });

                    const placementWidth = maxX - minX;
                    const placementHeight = maxY - minY;

                    const offsetX = (container.length - placementWidth) / 2 - minX;
                    const offsetY = (container.width - placementHeight) / 2 - minY;

                    placedPallets.forEach(p => {
                        p.x += offsetX;
                        p.y += offsetY;
                    });
                }
                
                const placedCount = allPalletsGenerated.filter(p => p.placed).length;
                const rotatedCount = allPalletsGenerated.filter(p => p.placed && p.rotated).length;
                
                elements.loadingAnimation.style.display = 'none';
                elements.manualInstructions.style.display = 'block';
                elements.exportBtn.style.display = 'block';
                
                renderAllPallets(container);
                updateStats(container);
                updateLegend();

                if (placedCount === allPalletsGenerated.length) {
                    utils.showSuccess(`ğŸ‰ å…¨${allPalletsGenerated.length}å€‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆãŒè‡ªå‹•é…ç½®ã•ã‚Œã¾ã—ãŸï¼ï¼ˆå›è»¢: ${rotatedCount}å€‹ï¼‰`);
                } else if (placedCount > 0) {
                    utils.showSuccess(`âš¡ ${placedCount}/${allPalletsGenerated.length}å€‹ã‚’è‡ªå‹•é…ç½®ï¼ˆå›è»¢: ${rotatedCount}å€‹ï¼‰ã€‚æ®‹ã‚Šã¯ãƒãƒ‹ãƒ¥ã‚¢ãƒ«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚`);
                } else {
                    utils.showSuccess(`ğŸ“¦ ${allPalletsGenerated.length}å€‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã§é…ç½®ã—ã¦ãã ã•ã„ã€‚`);
                }
            }, CONSTANTS.ANIMATION_DELAY);
        }

        // 3Dç©ã¿é‡ã­å¯¾å¿œã®é…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
        function packPallets2D(palletsToPlace, container, clearance) {
            const placed = [];
            const stackingEnabled = elements.enableStacking.checked;
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚¿ã‚¤ãƒ—ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groups = {};
            palletsToPlace.forEach(pallet => {
                const key = `${pallet.length}x${pallet.width}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(pallet);
            });
            
            console.log(`ã‚°ãƒ«ãƒ¼ãƒ—æ•°: ${Object.keys(groups).length}`);
            Object.entries(groups).forEach(([key, pallets]) => {
                console.log(`  ${key}: ${pallets.length}å€‹`);
            });
            
            let specialMaxX = 0;
            
            // 100Ã—125ãƒ‘ãƒ¬ãƒƒãƒˆã®ç‰¹æ®Šé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³
            if (groups['100x125'] && groups['100x125'].length >= 8) {
                const specialPlaced = trySpecialPattern100x125(groups['100x125'], container, clearance);
                if (specialPlaced.length > 0) {
                    console.log(`100Ã—125ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³ã§ ${specialPlaced.length} å€‹é…ç½®æˆåŠŸ`);
                    // é…ç½®ã•ã‚ŒãŸãƒ‘ãƒ¬ãƒƒãƒˆã®æƒ…å ±ã‚’æ›´æ–°
                    specialPlaced.forEach(p => {
                        const original = allPalletsGenerated.find(pallet => 
                            pallet.id === p.id && pallet.instance === p.instance
                        );
                        if (original) {
                            original.placed = true;
                            original.x = p.x;
                            original.y = p.y;
                            original.finalLength = p.finalLength;
                            original.finalWidth = p.finalWidth;
                            original.rotated = p.rotated;
                        }
                        placed.push({
                            x: p.x,
                            y: p.y,
                            length: p.finalLength,
                            width: p.finalWidth
                        });
                        specialMaxX = Math.max(specialMaxX, p.x + p.finalLength);
                    });
                }
            }
            
            // 110Ã—110ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚°ãƒªãƒƒãƒ‰é…ç½®
            if (groups['110x110']) {
                const startX = specialMaxX + clearance;
                const gridPlaced = placeGridPattern(groups['110x110'], container, clearance, placed, startX);
                gridPlaced.forEach(p => {
                    const original = allPalletsGenerated.find(pallet => 
                        pallet.id === p.id && pallet.instance === p.instance
                    );
                    if (original) {
                        original.placed = true;
                        original.x = p.x;
                        original.y = p.y;
                        original.finalLength = p.finalLength;
                        original.finalWidth = p.finalWidth;
                        original.rotated = p.rotated;
                    }
                    placed.push({
                        x: p.x,
                        y: p.y,
                        length: p.finalLength,
                        width: p.finalWidth
                    });
                });
            }
            
            // æ®‹ã‚Šã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’é€šå¸¸é…ç½®
            const remainingPallets = palletsToPlace.filter(p => !p.placed);
            console.log(`æ®‹ã‚Šãƒ‘ãƒ¬ãƒƒãƒˆæ•°: ${remainingPallets.length}`);
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚µã‚¤ã‚ºã§ã‚½ãƒ¼ãƒˆï¼ˆå¤§ãã„ã‚‚ã®ã‹ã‚‰ï¼‰
            remainingPallets.sort((a, b) => (b.length * b.width) - (a.length * a.width));
            
            remainingPallets.forEach(pallet => {
                let bestPosition = null;
                let bestScore = Infinity;
                let bestRotated = false;
                
                // é€šå¸¸é…ç½®ã¨å›è»¢é…ç½®ã®ä¸¡æ–¹ã‚’è©¦è¡Œ
                const orientations = pallet.length !== pallet.width ?
                    [[pallet.length, pallet.width, false], [pallet.width, pallet.length, true]] :
                    [[pallet.length, pallet.width, false]];
                
                orientations.forEach(([length, width, rotated]) => {
                    // ã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã§é…ç½®ä½ç½®ã‚’æ¢ç´¢
                    for (let y = 0; y <= container.width - width; y += 5) {
                        for (let x = 0; x <= container.length - length; x += 5) {
                            if (canPlace2D(x, y, length, width, placed, clearance)) {
                                // å·¦ä¸‹ã‚’å„ªå…ˆã™ã‚‹ã‚¹ã‚³ã‚¢è¨ˆç®—
                                const score = x + y * 2;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPosition = { x, y };
                                    bestRotated = rotated;
                                }
                            }
                        }
                    }
                });
                
                if (bestPosition) {
                    pallet.placed = true;
                    pallet.x = bestPosition.x;
                    pallet.y = bestPosition.y;
                    pallet.rotated = bestRotated;
                    
                    if (bestRotated) {
                        pallet.finalLength = pallet.width;
                        pallet.finalWidth = pallet.length;
                    } else {
                        pallet.finalLength = pallet.length;
                        pallet.finalWidth = pallet.width;
                    }
                    
                    placed.push({
                        x: pallet.x,
                        y: pallet.y,
                        length: pallet.finalLength,
                        width: pallet.finalWidth
                    });
                }
            });
            
            console.log(`é€šå¸¸é…ç½®ã§è¿½åŠ é…ç½®: ${remainingPallets.filter(p => p.placed).length}å€‹`);
            
            // 3Dç©ã¿é‡ã­å‡¦ç†
            if (stackingEnabled) {
                console.log('3Dç©ã¿é‡ã­å‡¦ç†ã‚’é–‹å§‹...');
                perform3DStacking(palletsToPlace, container, clearance, placed);
            }
            
            // æœªé…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆã®æ•´åˆ—
            const unplaced = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
            if (unplaced.length > 0) {
                console.log(`æœªé…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆ: ${unplaced.length}å€‹`);
                let offsetX = 0;
                let offsetY = container.width + 30;
                let currentRowMaxHeight = 0;
                
                unplaced.forEach(pallet => {
                    if (offsetX + pallet.finalLength > container.length) {
                        offsetX = 0;
                        offsetY += currentRowMaxHeight + 10;
                        currentRowMaxHeight = 0;
                    }
                    
                    pallet.x = offsetX;
                    pallet.y = offsetY;
                    
                    currentRowMaxHeight = Math.max(currentRowMaxHeight, pallet.finalWidth);
                    offsetX += pallet.finalLength + 10;
                });
            }
        }
        
        // 100Ã—125ãƒ‘ãƒ¬ãƒƒãƒˆã®ç‰¹æ®Šé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³
        function trySpecialPattern100x125(pallets, container, clearance) {
            const placedPallets = [];
            const areaPlaced = [];
            
            const topPattern = [true, false, true, false]; // rotated for top row
            const bottomPattern = [false, true, false, true]; // rotated for bottom row
            
            const startX = 0;
            const startY = 0;
            
            let topX = startX;
            let colHeights = [];
            
            // Place top row
            topPattern.forEach((rotated, col) => {
                if (placedPallets.length >= pallets.length) return;
                
                const pallet = pallets[placedPallets.length];
                const length = rotated ? 125 : 100;
                const width = rotated ? 100 : 125;
                const x = topX;
                const y = startY;
                
                if (canPlace2D(x, y, length, width, areaPlaced, clearance, container)) {
                    placedPallets.push({
                        ...pallet,
                        x,
                        y,
                        finalLength: length,
                        finalWidth: width,
                        rotated,
                        placed: true
                    });
                    
                    areaPlaced.push({ x, y, length, width });
                    colHeights[col] = width;
                    topX += length + clearance;
                }
            });
            
            // Place bottom row
            let bottomX = startX;
            bottomPattern.forEach((rotated, col) => {
                if (placedPallets.length >= pallets.length) return;
                
                const pallet = pallets[placedPallets.length];
                const length = rotated ? 125 : 100;
                const width = rotated ? 100 : 125;
                const x = bottomX;
                const y = startY + (colHeights[col] || 0) + clearance;
                
                if (y + width <= container.width && canPlace2D(x, y, length, width, areaPlaced, clearance, container)) {
                    placedPallets.push({
                        ...pallet,
                        x,
                        y,
                        finalLength: length,
                        finalWidth: width,
                        rotated,
                        placed: true
                    });
                    
                    areaPlaced.push({ x, y, length, width });
                    bottomX += length + clearance;
                }
            });
            
            return placedPallets;
        }
        
        // ã‚°ãƒªãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³é…ç½®ï¼ˆ110Ã—110ç”¨ï¼‰
        function placeGridPattern(pallets, container, clearance, alreadyPlaced, startX) {
            const placedPallets = [];
            const length = 110;
            const width = 110;
            
            const cols = Math.floor((container.length - startX) / (length + clearance));
            const rows = Math.floor(container.width / (width + clearance));
            
            let palletIndex = 0;
            
            for (let row = 0; row < rows && palletIndex < pallets.length; row++) {
                for (let col = 0; col < cols && palletIndex < pallets.length; col++) {
                    const x = startX + col * (length + clearance);
                    const y = row * (width + clearance);
                    
                    if (canPlace2D(x, y, length, width, alreadyPlaced, clearance)) {
                        const pallet = pallets[palletIndex++];
                        placedPallets.push({
                            ...pallet,
                            x: x,
                            y: y,
                            finalLength: length,
                            finalWidth: width,
                            rotated: false,
                            placed: true
                        });
                    }
                }
            }
            
            console.log(`110Ã—110 ã‚°ãƒªãƒƒãƒ‰é…ç½®: ${cols}åˆ—Ã—${rows}è¡Œã§${placedPallets.length}å€‹é…ç½®`);
            
            return placedPallets;
        }

        // 3Dç©ã¿é‡ã­å‡¦ç†
        function perform3DStacking(palletsToPlace, container, clearance, placed2D) {
            console.log('3Dç©ã¿é‡ã­å‡¦ç†ã‚’å®Ÿè¡Œä¸­...');
            
            // é…ç½®æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆã‚’å–å¾—
            const placedPallets = allPalletsGenerated.filter(p => p.placed && !p.deleted);
            const unplacedPallets = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
            
            if (unplacedPallets.length === 0) {
                console.log('ç©ã¿é‡ã­å¯¾è±¡ã®ãƒ‘ãƒ¬ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“');
                return;
            }
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’é‡é‡ã¨é«˜ã•ã§ã‚½ãƒ¼ãƒˆï¼ˆé‡ã„ã‚‚ã®ã€é«˜ã„ã‚‚ã®ã‚’å„ªå…ˆï¼‰
            unplacedPallets.sort((a, b) => {
                const weightDiff = (b.weight || 0) - (a.weight || 0);
                if (weightDiff !== 0) return weightDiff;
                return (b.height || 0) - (a.height || 0);
            });
            
            console.log(`ç©ã¿é‡ã­å¯¾è±¡ãƒ‘ãƒ¬ãƒƒãƒˆ: ${unplacedPallets.length}å€‹`);
            
            // å„æœªé…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆã«å¯¾ã—ã¦ç©ã¿é‡ã­å¯èƒ½ãªä½ç½®ã‚’æ¢ç´¢
            unplacedPallets.forEach(pallet => {
                if (pallet.placed) return;
                
                const bestStackPosition = findBestStackPosition(pallet, placedPallets, container, clearance);
                if (bestStackPosition) {
                    // ç©ã¿é‡ã­é…ç½®
                    pallet.x = bestStackPosition.x;
                    pallet.y = bestStackPosition.y;
                    pallet.z = bestStackPosition.z;
                    pallet.placed = true;
                    pallet.stackedOn = bestStackPosition.stackedOn;
                    
                    // ç©ã¿é‡ã­é–¢ä¿‚ã‚’æ›´æ–°
                    if (bestStackPosition.stackedOn) {
                        const basePallet = allPalletsGenerated.find(p => 
                            p.id === bestStackPosition.stackedOn.id && 
                            p.instance === bestStackPosition.stackedOn.instance
                        );
                        if (basePallet) {
                            basePallet.stackedBy.push({
                                id: pallet.id,
                                instance: pallet.instance
                            });
                        }
                    }
                    
                    console.log(`ãƒ‘ãƒ¬ãƒƒãƒˆ#${pallet.palletNumber} ã‚’ç©ã¿é‡ã­é…ç½®: (${pallet.x}, ${pallet.y}, ${pallet.z})`);
                }
            });
            
            // é‡å¿ƒè¨ˆç®—ã¨å®‰å®šæ€§ãƒã‚§ãƒƒã‚¯
            const stabilityResult = calculateStackingStability(placedPallets);
            console.log('ç©ã¿é‡ã­å®‰å®šæ€§:', stabilityResult);
            
            // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›
            debugLog('3Dç©ã¿é‡ã­å®Œäº†', {
                totalPlaced: placedPallets.length + unplacedPallets.filter(p => p.placed).length,
                stackedCount: unplacedPallets.filter(p => p.placed && p.stackedOn).length,
                stability: stabilityResult
            });
        }
        
        // æœ€é©ãªç©ã¿é‡ã­ä½ç½®ã‚’æ¢ç´¢
        function findBestStackPosition(pallet, placedPallets, container, clearance) {
            let bestPosition = null;
            let bestScore = -Infinity;
            
            // å„é…ç½®æ¸ˆã¿ãƒ‘ãƒ¬ãƒƒãƒˆã®ä¸Šã«ç©ã¿é‡ã­ã‚’è©¦è¡Œ
            placedPallets.forEach(basePallet => {
                // ç©ã¿é‡ã­åˆ¶ç´„ãƒã‚§ãƒƒã‚¯
                if (!pallet.canStackBelow || !basePallet.canStackAbove) return;
                
                // ã‚µã‚¤ã‚ºåˆ¶ç´„ãƒã‚§ãƒƒã‚¯
                if (pallet.finalLength > basePallet.finalLength || 
                    pallet.finalWidth > basePallet.finalWidth) return;
                
                // é«˜ã•åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ï¼ˆæ—¢å­˜ã‚¹ã‚¿ãƒƒã‚¯ã®æœ€ä¸Šé¢ã‚’è€ƒæ…®ï¼‰
                const containerHeight = containers[elements.containerType.value].height;
                const topZ = getTopZForBase(basePallet);
                const totalHeight = topZ + pallet.finalHeight;
                if (totalHeight > containerHeight) return;
                
                // é‡é‡åˆ¶ç´„ãƒã‚§ãƒƒã‚¯ï¼ˆç©ã¿é‡ã­åˆ¶é™ï¼‰
                const totalWeight = calculateStackWeight(basePallet) + pallet.weight;
                if (totalWeight > 2000) return; // ç©ã¿é‡ã­é‡é‡åˆ¶é™
                
                // ä½ç½®è¨ˆç®—
                const x = basePallet.x;
                const y = basePallet.y;
                const z = topZ;
                
                // ã‚¹ã‚³ã‚¢è¨ˆç®—ï¼ˆé‡å¿ƒã€é‡é‡åˆ†å¸ƒã€é«˜ã•åŠ¹ç‡ã‚’è€ƒæ…®ï¼‰
                const score = calculateStackingScore(pallet, basePallet, x, y, z);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestPosition = { x, y, z, stackedOn: basePallet };
                }
            });
            
            return bestPosition;
        }
        
        // ç©ã¿é‡ã­ã‚¹ã‚³ã‚¢è¨ˆç®—
        function calculateStackingScore(pallet, basePallet, x, y, z) {
            let score = 0;
            
            // é«˜ã•åŠ¹ç‡ï¼ˆé«˜ã„ã»ã©è‰¯ã„ï¼‰
            score += z * 0.1;
            
            // é‡é‡åˆ†å¸ƒï¼ˆè»½ã„ã‚‚ã®ã‚’ä¸Šã«ï¼‰
            if (pallet.weight < basePallet.weight) score += 50;
            
            // ã‚µã‚¤ã‚ºé©åˆåº¦ï¼ˆã´ã£ãŸã‚Šåˆã†ã»ã©è‰¯ã„ï¼‰
            const lengthFit = 1 - Math.abs(pallet.finalLength - basePallet.finalLength) / basePallet.finalLength;
            const widthFit = 1 - Math.abs(pallet.finalWidth - basePallet.finalWidth) / basePallet.finalWidth;
            score += (lengthFit + widthFit) * 25;
            
            // é‡å¿ƒå®‰å®šæ€§
            const centerX = (basePallet.x + basePallet.finalLength / 2 + pallet.finalLength / 2) / 2;
            const centerY = (basePallet.y + basePallet.finalWidth / 2 + pallet.finalWidth / 2) / 2;
            const containerCenterX = containers[elements.containerType.value].length / 2;
            const containerCenterY = containers[elements.containerType.value].width / 2;
            
            const distanceFromCenter = Math.sqrt(
                Math.pow(centerX - containerCenterX, 2) + 
                Math.pow(centerY - containerCenterY, 2)
            );
            score -= distanceFromCenter * 0.01; // ä¸­å¿ƒã«è¿‘ã„ã»ã©è‰¯ã„
            
            return score;
        }
        
        // ç©ã¿é‡ã­é‡é‡è¨ˆç®—
        function calculateStackWeight(basePallet) {
            let totalWeight = basePallet.weight || 0;
            
            // ã“ã®ãƒ‘ãƒ¬ãƒƒãƒˆã®ä¸Šã«ç©ã¾ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¬ãƒƒãƒˆã®é‡é‡ï¼ˆå†å¸°çš„ï¼‰ã‚’åŠ ç®—
            (basePallet.stackedBy || []).forEach(stackedPallet => {
                const pallet = allPalletsGenerated.find(p => 
                    p.id === stackedPallet.id && p.instance === stackedPallet.instance
                );
                if (pallet) {
                    totalWeight += pallet.weight || 0;
                    totalWeight += calculateStackWeight(pallet) - (pallet.weight || 0);
                }
            });
            
            return totalWeight;
        }

        // åŸºåº•ãƒ‘ãƒ¬ãƒƒãƒˆã®ç¾åœ¨ã®æœ€ä¸Šé¢Zåº§æ¨™ï¼ˆz + heightï¼‰ã®å–å¾—
        function getTopZForBase(basePallet) {
            let topZ = (basePallet.z || 0) + (basePallet.finalHeight || 0);
            
            (basePallet.stackedBy || []).forEach(stackedPallet => {
                const pallet = allPalletsGenerated.find(p => 
                    p.id === stackedPallet.id && p.instance === stackedPallet.instance
                );
                if (pallet && pallet.placed) {
                    const palletTop = (pallet.z || 0) + (pallet.finalHeight || 0);
                    if (palletTop > topZ) topZ = palletTop;
                }
            });
            
            return topZ;
        }
        
        // ç©ã¿é‡ã­å®‰å®šæ€§è¨ˆç®—
        function calculateStackingStability(placedPallets) {
            const container = containers[elements.containerType.value];
            let totalWeight = 0;
            let weightedCenterX = 0;
            let weightedCenterY = 0;
            let weightedCenterZ = 0;
            
            placedPallets.forEach(pallet => {
                const weight = pallet.weight || 0;
                totalWeight += weight;
                
                const centerX = pallet.x + pallet.finalLength / 2;
                const centerY = pallet.y + pallet.finalWidth / 2;
                const centerZ = pallet.z + pallet.finalHeight / 2;
                
                weightedCenterX += centerX * weight;
                weightedCenterY += centerY * weight;
                weightedCenterZ += centerZ * weight;
            });
            
            if (totalWeight === 0) return { stable: true, centerOfGravity: { x: 0, y: 0, z: 0 } };
            
            const centerOfGravity = {
                x: weightedCenterX / totalWeight,
                y: weightedCenterY / totalWeight,
                z: weightedCenterZ / totalWeight
            };
            
            // é‡å¿ƒãŒã‚³ãƒ³ãƒ†ãƒŠä¸­å¿ƒã«è¿‘ã„ã»ã©å®‰å®š
            const containerCenterX = container.length / 2;
            const containerCenterY = container.width / 2;
            const containerCenterZ = container.height / 2;
            
            const distanceFromCenter = Math.sqrt(
                Math.pow(centerOfGravity.x - containerCenterX, 2) + 
                Math.pow(centerOfGravity.y - containerCenterY, 2) + 
                Math.pow(centerOfGravity.z - containerCenterZ, 2)
            );
            
            const maxDistance = Math.sqrt(
                Math.pow(container.length / 2, 2) + 
                Math.pow(container.width / 2, 2) + 
                Math.pow(container.height / 2, 2)
            );
            
            const stability = Math.max(0, 100 - (distanceFromCenter / maxDistance) * 100);
            
            return {
                stable: stability > 70,
                stability: Math.round(stability),
                centerOfGravity,
                totalWeight,
                distanceFromCenter: Math.round(distanceFromCenter)
            };
        }
        
        // ã‚¨ãƒªã‚¢åˆ†å‰²é…ç½®æˆ¦ç•¥
        function tryAreaDivisionPlacement(groups, container, clearance) {
            const placedPallets = [];
            const groupKeys = Object.keys(groups);
            
            if (groupKeys.length !== 2) return placedPallets;
            
            // 2ã¤ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’å–å¾—
            const group1 = groups[groupKeys[0]];
            const group2 = groups[groupKeys[1]];
            
            console.log(`ã‚¨ãƒªã‚¢åˆ†å‰²é…ç½®: ${groupKeys[0]} (${group1.length}å€‹) ã¨ ${groupKeys[1]} (${group2.length}å€‹)`);
            
            // å„ã‚°ãƒ«ãƒ¼ãƒ—ã®æœ€é©ãªé…ç½®å¹…ã‚’è¨ˆç®—
            const result1 = calculateOptimalGroupWidth(group1[0], container, clearance);
            const result2 = calculateOptimalGroupWidth(group2[0], container, clearance);
            
            // ã‚³ãƒ³ãƒ†ãƒŠã‚’å·¦å³ã«åˆ†å‰²ã™ã‚‹æœ€é©ãªä½ç½®ã‚’æ¢ç´¢
            let bestDivision = null;
            let maxPallets = 0;
            
            // 100x125ã¨110x110ã®ç‰¹æ®Šã‚±ãƒ¼ã‚¹
            if ((group1[0].length === 100 && group1[0].width === 125 && group2[0].length === 110) ||
                (group2[0].length === 100 && group2[0].width === 125 && group1[0].length === 110)) {
                
                // 100x125ã‚’å·¦,110x110ã‚’å³ã«é…ç½®
                const divX = 500; // 100x125ç”¨ã«ç´„500cmç¢ºä¿
                const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                
                let leftPlaced, rightPlaced;
                if (group1[0].length === 100 && group1[0].width === 125) {
                    leftPlaced = placeGroupInArea(group1, leftArea, clearance, true);
                    rightPlaced = placeGroupInArea(group2, rightArea, clearance, false);
                } else {
                    leftPlaced = placeGroupInArea(group2, leftArea, clearance, true);
                    rightPlaced = placeGroupInArea(group1, rightArea, clearance, false);
                }
                
                bestDivision = { divX, leftPlaced, rightPlaced };
                maxPallets = leftPlaced.length + rightPlaced.length;
                
            } else {
                // ä¸€èˆ¬çš„ãªã‚±ãƒ¼ã‚¹ã®åˆ†å‰²ä½ç½®æ¢ç´¢
                const testDivisions = [];
                
                // å„ã‚°ãƒ«ãƒ¼ãƒ—ã®å¿…è¦å¹…ã«åŸºã¥ã„ã¦å€™è£œã‚’ç”Ÿæˆ
                for (let i = 1; i <= 5; i++) {
                    testDivisions.push(result1.minWidth * i);
                    testDivisions.push(container.length - result2.minWidth * i);
                }
                
                // é‡è¤‡ã‚’é™¤å»ã—ã¦ã‚½ãƒ¼ãƒˆ
                const uniqueDivisions = [...new Set(testDivisions)]
                    .filter(d => d >= result1.minWidth && d <= container.length - result2.minWidth)
                    .sort((a, b) => a - b);
                
                // å„åˆ†å‰²ä½ç½®ã‚’è©¦è¡Œ
                uniqueDivisions.forEach(divX => {
                    const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                    const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                    
                    // å·¦å´ã‚¨ãƒªã‚¢ã«group1ã‚’é…ç½®
                    const leftPlaced = placeGroupInArea(group1, leftArea, clearance, true);
                    // å³å´ã‚¨ãƒªã‚¢ã«group2ã‚’é…ç½®
                    const rightPlaced = placeGroupInArea(group2, rightArea, clearance, false);
                    
                    const totalPlaced = leftPlaced.length + rightPlaced.length;
                    if (totalPlaced > maxPallets) {
                        maxPallets = totalPlaced;
                        bestDivision = { divX, leftPlaced, rightPlaced };
                    }
                });
                
                // å·¦å³ã‚’å…¥ã‚Œæ›¿ãˆãŸé…ç½®ã‚‚è©¦è¡Œ
                uniqueDivisions.forEach(divX => {
                    const leftArea = { x: 0, y: 0, width: divX, height: container.width };
                    const rightArea = { x: divX, y: 0, width: container.length - divX, height: container.width };
                    
                    // å·¦å´ã‚¨ãƒªã‚¢ã«group2ã‚’é…ç½®
                    const leftPlaced = placeGroupInArea(group2, leftArea, clearance, true);
                    // å³å´ã‚¨ãƒªã‚¢ã«group1ã‚’é…ç½®
                    const rightPlaced = placeGroupInArea(group1, rightArea, clearance, false);
                    
                    const totalPlaced = leftPlaced.length + rightPlaced.length;
                    if (totalPlaced > maxPallets) {
                        maxPallets = totalPlaced;
                        bestDivision = { divX, leftPlaced, rightPlaced };
                    }
                });
            }
            
            // æœ€é©ãªåˆ†å‰²ã§é…ç½®
            if (bestDivision) {
                console.log(`æœ€é©åˆ†å‰²ä½ç½®: ${bestDivision.divX}cm, é…ç½®æ•°: ${maxPallets}å€‹`);
                placedPallets.push(...bestDivision.leftPlaced);
                placedPallets.push(...bestDivision.rightPlaced);
            }
            
            return placedPallets;
        }
        
        // ã‚°ãƒ«ãƒ¼ãƒ—ã®æœ€é©é…ç½®å¹…ã‚’è¨ˆç®—
        function calculateOptimalGroupWidth(samplePallet, container, clearance) {
            const orientations = samplePallet.length !== samplePallet.width ?
                [[samplePallet.length, samplePallet.width], [samplePallet.width, samplePallet.length]] :
                [[samplePallet.length, samplePallet.width]];
            
            let minWidth = Infinity;
            let maxCols = 0;
            
            orientations.forEach(([length, width]) => {
                const cols = Math.floor(container.length / (length + clearance));
                if (cols > 0) {
                    const requiredWidth = cols * (length + clearance) - clearance;
                    minWidth = Math.min(minWidth, length + clearance);
                    maxCols = Math.max(maxCols, cols);
                }
            });
            
            return { minWidth, maxCols };
        }
        
        // ã‚¨ãƒªã‚¢å†…ã«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’é…ç½®
        function placeGroupInArea(group, area, clearance, allowMixedOrientation) {
            const placed = [];
            const areaPlaced = [];
            
            // ã‚¨ãƒªã‚¢å†…ã§ã®æœ€é©ãªé…ç½®ã‚’è¨ˆç®—
            const samplePallet = group[0];
            const orientations = samplePallet.length !== samplePallet.width ?
                [[samplePallet.length, samplePallet.width, false], [samplePallet.width, samplePallet.length, true]] :
                [[samplePallet.length, samplePallet.width, false]];
            
            let palletIndex = 0;
            
            // æ··åˆé…ç½®ã‚’è¨±å¯ã™ã‚‹å ´åˆï¼ˆå·¦å´ã‚¨ãƒªã‚¢ï¼‰
            if (allowMixedOrientation && orientations.length > 1) {
                // 100Ã—125ãƒ‘ãƒ¬ãƒƒãƒˆã®ç‰¹æ®Šé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³
                if (samplePallet.length === 100 && samplePallet.width === 125) {
                    // ä¸Šéƒ¨ã«æ¨ªå‘ãï¼ˆ125Ã—100ï¼‰ã‚’2åˆ—
                    let currentY = area.y;
                    
                    // 1åˆ—ç›®ï¼šæ¨ªå‘ã2å€‹
                    for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                        const x = area.x + i * 125;
                        if (x + 125 <= area.x + area.width) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x,
                                y: currentY,
                                finalLength: 125,
                                finalWidth: 100,
                                rotated: true,
                                placed: true
                            });
                            areaPlaced.push({ x, y: currentY, length: 125, width: 100 });
                        }
                    }
                    
                    currentY += 100 + clearance;
                    
                    // 2åˆ—ç›®ï¼šç¸¦å‘ãï¼ˆ100Ã—125ï¼‰ã‚’2å€‹
                    for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                        const x = area.x + i * 100;
                        if (x + 100 <= area.x + area.width) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x,
                                y: currentY,
                                finalLength: 100,
                                finalWidth: 125,
                                rotated: false,
                                placed: true
                            });
                            areaPlaced.push({ x, y: currentY, length: 100, width: 125 });
                        }
                    }
                    
                    // 3åˆ—ç›®ï¼šä¸‹éƒ¨ã«æ¨ªå‘ã2å€‹ + ç¸¦å‘ã1å€‹
                    if (palletIndex < group.length) {
                        currentY = area.y;
                        const x3Start = area.x + 250 + clearance;
                        
                        // æ¨ªå‘ã2å€‹ï¼ˆä¸Šä¸‹ã«é…ç½®ï¼‰
                        for (let i = 0; i < 2 && palletIndex < group.length; i++) {
                            const y = currentY + i * 100;
                            if (x3Start + 125 <= area.x + area.width && y + 100 <= area.y + area.height) {
                                const pallet = group[palletIndex++];
                                placed.push({
                                    ...pallet,
                                    x: x3Start,
                                    y: y,
                                    finalLength: 125,
                                    finalWidth: 100,
                                    rotated: true,
                                    placed: true
                                });
                                areaPlaced.push({ x: x3Start, y, length: 125, width: 100 });
                            }
                        }
                        
                    // æ®‹ã‚Šã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’é…ç½®ï¼ˆ4åˆ—ç›®ï¼‰
                    if (palletIndex < group.length && area.width >= 500) {
                        const x4Start = 500;
                        
                        // ç¸¦å‘ã1å€‹ï¼ˆå³ä¸‹ï¼‰
                        if (palletIndex < group.length) {
                            const pallet = group[palletIndex++];
                            placed.push({
                                ...pallet,
                                x: x4Start,
                                y: area.y,
                                finalLength: 100,
                                finalWidth: 125,
                                rotated: false,
                                placed: true
                            });
                            areaPlaced.push({ x: x4Start, y: area.y, length: 100, width: 125 });
                        }
                    }
                    }
                } else {
                    // ãã®ä»–ã®ãƒ‘ãƒ¬ãƒƒãƒˆã®æ··åˆé…ç½®
                    let currentY = area.y;
                    
                    while (currentY < area.y + area.height && palletIndex < group.length) {
                        const useRotated = Math.floor((currentY - area.y) / 150) % 2 === 1;
                        const [length, width, rotated] = useRotated && orientations.length > 1 ? 
                            orientations[1] : orientations[0];
                        
                        let currentX = area.x;
                        let rowHeight = 0;
                        
                        while (currentX + length <= area.x + area.width && palletIndex < group.length) {
                            const pallet = group[palletIndex];
                            
                            if (canPlace2D(currentX, currentY, length, width, areaPlaced, clearance)) {
                                placed.push({
                                    ...pallet,
                                    x: currentX,
                                    y: currentY,
                                    finalLength: length,
                                    finalWidth: width,
                                    rotated: rotated,
                                    placed: true
                                });
                                
                                areaPlaced.push({
                                    x: currentX,
                                    y: currentY,
                                    length: length,
                                    width: width
                                });
                                
                                palletIndex++;
                                currentX += length + clearance;
                                rowHeight = Math.max(rowHeight, width);
                            } else {
                                break;
                            }
                        }
                        
                        currentY += rowHeight + clearance;
                    }
                }
            } else {
                // å˜ä¸€å‘ãé…ç½®ï¼ˆå³å´ã‚¨ãƒªã‚¢ç”¨ã€110Ã—110ã®æ•´ç„¶é…ç½®ï¼‰
                const [length, width, rotated] = orientations[0];
                const cols = Math.floor(area.width / (length + clearance));
                const rows = Math.floor(area.height / (width + clearance));
                
                let placedInArea = 0;
                for (let row = 0; row < rows && palletIndex < group.length; row++) {
                    for (let col = 0; col < cols && palletIndex < group.length; col++) {
                        const x = area.x + col * (length + clearance);
                        const y = area.y + row * (width + clearance);
                        const pallet = group[palletIndex];
                        
                        if (canPlace2D(x, y, length, width, areaPlaced, clearance)) {
                            placed.push({
                                ...pallet,
                                x: x,
                                y: y,
                                finalLength: length,
                                finalWidth: width,
                                rotated: rotated,
                                placed: true
                            });
                            
                            areaPlaced.push({
                                x: x,
                                y: y,
                                length: length,
                                width: width
                            });
                            
                            palletIndex++;
                            placedInArea++;
                        }
                    }
                }
                
                console.log(`${length}Ã—${width}ãƒ‘ãƒ¬ãƒƒãƒˆ: ${cols}åˆ—Ã—${rows}è¡Œã§${placedInArea}å€‹é…ç½®`);
            }
            
            return placed;
        }

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°
        function renderAllPallets(container) {
            const containerFloor = elements.containerFloor;
            const workArea = containerFloor.parentElement;
            
            renderConfig.scale = utils.calculateScale(container);
            const actualDisplayWidth = container.length * renderConfig.scale;
            const actualDisplayHeight = container.width * renderConfig.scale;
            
            // ã‚³ãƒ³ãƒ†ãƒŠã®è¡¨ç¤ºè¨­å®š
            containerFloor.style.width = `${actualDisplayWidth}px`;
            containerFloor.style.height = `${actualDisplayHeight}px`;
            containerFloor.style.position = 'absolute';
            containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            // ä½œæ¥­ã‚¨ãƒªã‚¢ã®ã‚µã‚¤ã‚ºè¨ˆç®—
            const unplacedPallets = allPalletsGenerated.filter(p => !p.deleted && !p.placed);
            let maxBottomY = actualDisplayHeight + CONSTANTS.CONTAINER_OFFSET_Y;
            
            if (unplacedPallets.length > 0) {
                const bottomMostY = Math.max(...unplacedPallets.map(p => 
                    ((p.y + p.finalWidth) * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y
                ));
                maxBottomY = Math.max(maxBottomY, bottomMostY + 50);
            }
            
            workArea.style.width = `${actualDisplayWidth + CONSTANTS.CONTAINER_OFFSET_X + 50}px`;
            workArea.style.height = `${Math.max(maxBottomY, 400 + CONSTANTS.CONTAINER_OFFSET_Y)}px`;
            workArea.style.position = 'relative';
            
            // æ—¢å­˜ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’å‰Šé™¤
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’æç”»
            allPalletsGenerated.forEach(pallet => {
                if (pallet.deleted) return;
                
                const el = document.createElement('div');
                el.className = 'pallet-2d';
                el.dataset.palletId = pallet.id;
                el.dataset.instance = pallet.instance;
                
                const palletWidth = pallet.finalLength * renderConfig.scale;
                const palletHeight = pallet.finalWidth * renderConfig.scale;
                const palletLeft = (pallet.x * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_X;
                const palletTop = (pallet.y * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y;
                
                Object.assign(el.style, {
                    width: `${palletWidth}px`,
                    height: `${palletHeight}px`,
                    left: `${palletLeft}px`,
                    top: `${palletTop}px`,
                    background: pallet.color,
                    position: 'absolute'
                });
                
                if (pallet.rotated) {
                    el.style.background = `repeating-linear-gradient(45deg, ${pallet.color}, ${pallet.color} 10px, ${utils.adjustColor(pallet.color, -20)} 10px, ${utils.adjustColor(pallet.color, -20)} 20px)`;
                }
                
                // çŠ¶æ…‹ã«å¿œã˜ãŸã‚¯ãƒ©ã‚¹ä»˜ä¸
                const isOutside = isOutsideContainer(pallet, container);
                const isBottomPlaced = pallet.y > container.width;
                
                if (isBottomPlaced) {
                    el.classList.add('bottom-placed');
                } else if (isOutside) {
                    el.classList.add('outside-container');
                }
                
                // 3Dç©ã¿é‡ã­ã‚¯ãƒ©ã‚¹ä»˜ä¸
                if (elements.enableStacking.checked) {
                    if (pallet.stackedOn) {
                        el.classList.add('stacked');
                    } else if (pallet.stackedBy.length > 0) {
                        el.classList.add('base-pallet');
                    }
                }
                
                // 3Dæƒ…å ±ã‚’è¡¨ç¤º
                let stackInfo = '';
                if (elements.enableStacking.checked && pallet.stackedOn) {
                    stackInfo = `<div style="font-size: 10px; color: #e74c3c; font-weight: bold;">â†‘ç©ã¿é‡ã­</div>`;
                } else if (elements.enableStacking.checked && pallet.stackedBy.length > 0) {
                    stackInfo = `<div style="font-size: 10px; color: #27ae60; font-weight: bold;">â†“${pallet.stackedBy.length}å€‹ç©è¼‰</div>`;
                }
                
                const heightInfo = pallet.finalHeight > 0 ? ` H:${pallet.finalHeight}` : '';
                const weightInfo = pallet.weight > 0 ? ` ${pallet.weight}kg` : '';
                
                el.innerHTML = `
                    <div class="pallet-label">#${pallet.palletNumber} ${pallet.finalLength}Ã—${pallet.finalWidth}${heightInfo}${weightInfo}${pallet.rotated ? ' â†»' : ''}</div>
                    ${stackInfo}
                    <div class="pallet-controls">
                        <button class="rotate-btn" title="å›è»¢">â†»</button>
                        <button class="delete-btn" title="å‰Šé™¤">âœ•</button>
                    </div>
                `;
                
                workArea.appendChild(el);
            });
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è¨­å®šã‚’ä¿å­˜
            renderConfig.containerBounds = {
                left: CONSTANTS.CONTAINER_OFFSET_X,
                top: CONSTANTS.CONTAINER_OFFSET_Y,
                width: actualDisplayWidth,
                height: actualDisplayHeight
            };
            
            enableDragAndDropAndActions();
        }

        function isOutsideContainer(pallet, container) {
            return pallet.x < 0 || pallet.y < 0 ||
                   pallet.x + pallet.finalLength > container.length ||
                   pallet.y + pallet.finalWidth > container.width;
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½
        let isDDListenerAttached = false;
        function enableDragAndDropAndActions() {
            const workArea = elements.containerFloor.parentElement;
            if (isDDListenerAttached) return;

            let activePalletEl = null;
            let initialMouseX, initialMouseY;

            workArea.addEventListener('mousedown', handleMouseDown);
            isDDListenerAttached = true;

            function handleMouseDown(e) {
                const target = e.target;
                if (target.classList.contains('rotate-btn')) {
                    e.stopPropagation();
                    rotatePallet(target.closest('.pallet-2d'));
                } else if (target.classList.contains('delete-btn')) {
                    e.stopPropagation();
                    deletePallet(target.closest('.pallet-2d'));
                } else {
                    const palletEl = target.classList.contains('pallet-2d') ? target : target.closest('.pallet-2d');
                    if (palletEl) {
                        dragStart(e, palletEl);
                    }
                }
            }

            function dragStart(e, palletEl) {
                e.preventDefault();
                activePalletEl = palletEl;
                activePalletEl.classList.add('dragging');
                
                const palletRect = activePalletEl.getBoundingClientRect();
                const workAreaRect = workArea.getBoundingClientRect();
                
                initialMouseX = e.clientX - palletRect.left;
                initialMouseY = e.clientY - palletRect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
            }

            function drag(e) {
                if (!activePalletEl) return;
                e.preventDefault();
                
                const workAreaRect = workArea.getBoundingClientRect();
                let newLeft = e.clientX - workAreaRect.left - initialMouseX;
                let newTop = e.clientY - workAreaRect.top - initialMouseY;
                
                // ä½œæ¥­ã‚¨ãƒªã‚¢å†…ã«åˆ¶é™
                newLeft = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                          Math.min(newLeft, workArea.clientWidth - activePalletEl.clientWidth - CONSTANTS.MIN_DRAG_MARGIN));
                newTop = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                         Math.min(newTop, workArea.clientHeight - activePalletEl.clientHeight - CONSTANTS.MIN_DRAG_MARGIN));
                
                activePalletEl.style.left = `${newLeft}px`;
                activePalletEl.style.top = `${newTop}px`;
                
                updatePalletStatus(activePalletEl);
            }

            function dragEnd() {
                if (!activePalletEl) return;
                activePalletEl.classList.remove('dragging');
                updatePalletModel(activePalletEl);
                updateStats(containers[elements.containerType.value]);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                activePalletEl = null;
            }

            function rotatePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                // å¯¸æ³•ã‚’å…¥ã‚Œæ›¿ãˆ
                [palletData.finalLength, palletData.finalWidth] = [palletData.finalWidth, palletData.finalLength];
                palletData.rotated = !palletData.rotated;

                const container = containers[elements.containerType.value];
                palletEl.style.width = `${palletData.finalLength * renderConfig.scale}px`;
                palletEl.style.height = `${palletData.finalWidth * renderConfig.scale}px`;
                palletEl.querySelector('.pallet-label').textContent = 
                    `${palletData.finalLength}Ã—${palletData.finalWidth}${palletData.rotated ? ' â†»' : ''}`;
                
                // èƒŒæ™¯æ›´æ–°
                if (palletData.rotated) {
                    palletEl.style.background = `repeating-linear-gradient(45deg, ${palletData.color}, ${palletData.color} 10px, ${utils.adjustColor(palletData.color, -20)} 10px, ${utils.adjustColor(palletData.color, -20)} 20px)`;
                } else {
                    palletEl.style.background = palletData.color;
                }

                // ä½ç½®èª¿æ•´
                if (palletEl.offsetLeft + palletEl.offsetWidth > workArea.clientWidth) {
                    palletEl.style.left = `${Math.max(0, workArea.clientWidth - palletEl.offsetWidth)}px`;
                }
                if (palletEl.offsetTop + palletEl.offsetHeight > workArea.clientHeight) {
                    palletEl.style.top = `${Math.max(0, workArea.clientHeight - palletEl.offsetHeight)}px`;
                }
                
                updatePalletModel(palletEl);
                updatePalletStatus(palletEl);
                updateStats(container);
            }

            function deletePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                palletData.deleted = true;
                palletEl.remove();
                updateStats(containers[elements.containerType.value]);
                utils.showSuccess('ãƒ‘ãƒ¬ãƒƒãƒˆãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ');
            }

            function updatePalletStatus(palletEl) {
                const container = containers[elements.containerType.value];
                const palletData = {
                    x: (parseFloat(palletEl.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (parseFloat(palletEl.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    finalLength: palletEl.clientWidth / renderConfig.scale,
                    finalWidth: palletEl.clientHeight / renderConfig.scale
                };

                const isOutside = isOutsideContainer(palletData, container);
                const hasCollision = checkCollision(palletEl);
                
                palletEl.classList.toggle('outside-container', isOutside);
                palletEl.classList.toggle('colliding', hasCollision);
            }

            function checkCollision(draggedEl) {
                const container = containers[elements.containerType.value];
                const clearance = utils.getCurrentClearance();
                
                const draggedRect = {
                    x: (draggedEl.offsetLeft - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (draggedEl.offsetTop - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    length: draggedEl.clientWidth / renderConfig.scale,
                    width: draggedEl.clientHeight / renderConfig.scale
                };
                
                return allPalletsGenerated.some(p => {
                    if (p.deleted) return false;
                    const el = workArea.querySelector(`[data-pallet-id="${p.id}"][data-instance="${p.instance}"]`);
                    if (el === draggedEl) return false;
                    
                    return rectanglesOverlapWithClearance(
                        draggedRect,
                        { x: p.x, y: p.y, length: p.finalLength, width: p.finalWidth },
                        clearance
                    );
                });
            }

            function updatePalletModel(el) {
                const palletData = allPalletsGenerated.find(p =>
                    p.id == el.dataset.palletId && p.instance == el.dataset.instance
                );
                if (palletData) {
                    palletData.x = (parseFloat(el.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale;
                    palletData.y = (parseFloat(el.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale;
                }
            }
        }

        // çµ±è¨ˆæ›´æ–°
        function updateStats(container) {
            const visiblePallets = allPalletsGenerated.filter(p => !p.deleted);
            const insidePallets = visiblePallets.filter(p => !isOutsideContainer(p, container));
            
            const containerArea = (container.length * container.width) / 10000; // mÂ²
            const usedArea = insidePallets.reduce((sum, p) => 
                sum + (p.finalLength * p.finalWidth) / 10000, 0
            );
            
            // 3Dç©ã¿é‡ã­æƒ…å ±
            let stackingInfo = '';
            if (elements.enableStacking.checked) {
                const stackedPallets = insidePallets.filter(p => p.stackedOn);
                const basePallets = insidePallets.filter(p => p.stackedBy.length > 0);
                const maxHeight = Math.max(...insidePallets.map(p => p.z + p.finalHeight), 0);
                const totalWeight = insidePallets.reduce((sum, p) => sum + (p.weight || 0), 0);
                
                stackingInfo = `
                    <div class="stat-card">
                        <div class="stat-value">${stackedPallets.length}</div>
                        <div class="stat-label">ç©ã¿é‡ã­ãƒ‘ãƒ¬ãƒƒãƒˆ</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${maxHeight.toFixed(0)}cm</div>
                        <div class="stat-label">æœ€å¤§é«˜ã•</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${totalWeight}kg</div>
                        <div class="stat-label">ç·é‡é‡</div>
                    </div>
                `;
            }
            
            const totalInputPallets = pallets.reduce((sum, p) => sum + p.qty, 0);
            
            document.getElementById('inputPallets').textContent = totalInputPallets;
            document.getElementById('visiblePallets').textContent = visiblePallets.length;
            document.getElementById('loadedPallets').textContent = insidePallets.length;
            document.getElementById('loadingRate').textContent = 
                `${totalInputPallets > 0 ? Math.round((insidePallets.length / totalInputPallets) * 100) : 0}%`;
            document.getElementById('efficiency').textContent = 
                `${containerArea > 0 ? Math.round((usedArea / containerArea) * 100) : 0}%`;
            document.getElementById('remainingArea').textContent = `${(containerArea - usedArea).toFixed(2)}mÂ²`;
            
            // 3Dæƒ…å ±ã‚’è¿½åŠ 
            if (stackingInfo) {
                const statsContainer = document.getElementById('stats');
                const existing3DStats = statsContainer.querySelectorAll('.stat-card:nth-child(n+7)');
                existing3DStats.forEach(el => el.remove());
                statsContainer.insertAdjacentHTML('beforeend', stackingInfo);
            }
            
            elements.stats.style.display = 'grid';
        }

        function updateLegend() {
            elements.legend.innerHTML = '';
            if (pallets.length === 0) {
                elements.legend.style.display = 'none';
                return;
            }
            
            pallets.forEach(p => {
                elements.legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${p.color};"></div>
                        <span>${p.length}Ã—${p.width}cm (${p.qty}å€‹)</span>
                    </div>
                `;
            });
            elements.legend.style.display = 'flex';
        }

        // ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportLayoutAsImage() {
            const vizArea = document.querySelector('.visualization');
            elements.exportBtn.style.visibility = 'hidden';
            utils.showSuccess('ğŸ–¼ï¸ ç”»åƒã‚’ç”Ÿæˆä¸­ã§ã™...');
            
            html2canvas(vizArea, { 
                scale: 2, 
                useCORS: true, 
                backgroundColor: '#ffffff' 
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `container-loading-plan-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                elements.exportBtn.style.visibility = 'visible';
            }).catch(err => {
                console.error('Image export failed:', err);
                utils.showError('ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                elements.exportBtn.style.visibility = 'visible';
            });
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function setupEventListeners() {
            elements.addPalletBtn.addEventListener('click', () => palletManager.add());
            elements.calculateBtn.addEventListener('click', calculateLoading);
            elements.testBtn.addEventListener('click', runTestCase);
            elements.exportBtn.addEventListener('click', exportLayoutAsImage);
            elements.containerType.addEventListener('change', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.clearanceValue.addEventListener('input', () => {
                updateContainerInfo();
                clearResults();
            });
            
            // ãƒ‡ãƒãƒƒã‚°ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            document.getElementById('debugStacking').addEventListener('click', () => debug.testStacking());
            document.getElementById('debugGravity').addEventListener('click', () => debug.testGravity());
            document.getElementById('debugLayout').addEventListener('click', () => debug.testLayout());
            document.getElementById('debugClear').addEventListener('click', () => debug.clear());
            
            // Enterã‚­ãƒ¼ã§ã®è¿½åŠ 
            [elements.palletLength, elements.palletWidth, elements.palletHeight, elements.palletWeight, elements.palletQty].forEach(input => {
                input.addEventListener('keypress', e => {
                    if (e.key === 'Enter') palletManager.add();
                });
            });
        }

        function setupPresetButtons() {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.palletLength.value = this.dataset.length;
                    elements.palletWidth.value = this.dataset.width;
                    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é«˜ã•ã¨é‡é‡ã‚’è¨­å®š
                    elements.palletHeight.value = this.dataset.height || '120';
                    elements.palletWeight.value = this.dataset.weight || '500';
                    elements.palletQty.focus();
                });
            });
        }

        // åˆæœŸåŒ–
        function init() {
            initDarkMode();
            setupPresetButtons();
            setupEventListeners();
            updateContainerInfo();
        }

        document.addEventListener('DOMContentLoaded', init);
        
        // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        window.addEventListener('beforeunload', () => {
            console.log('Cleaning up before page unload...');
            memoryManager.cleanup();
        });
        
        // å®šæœŸçš„ãªãƒ¡ãƒ¢ãƒªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆ3åˆ†ã”ã¨ï¼‰
        setInterval(() => {
            memoryManager.cleanup();
        }, 3 * 60 * 1000);
    
</body>
</html>
