<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Automate Container Loader Planner - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- å…±é€šCSSãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ -->
    <link rel="stylesheet" href="../styles/variables.css">
    <link rel="stylesheet" href="../styles/components.css">
    <link rel="stylesheet" href="container-specific.css">
</head>
<body>
    <div class="container">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« -->
        <div class="header-controls" style="position: absolute; top: 24px; right: 32px; display: flex; gap: 12px; align-items: center; z-index: 10;">
            <button class="dark-mode-toggle" onclick="toggleDarkMode()" title="ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ" style="background: rgba(255, 255, 255, 0.1); border: none; border-radius: 6px; padding: 8px; color: rgba(255, 255, 255, 0.8); cursor: pointer; transition: all 0.2s ease; font-size: 16px; display: flex; align-items: center; justify-content: center; width: 36px; height: 32px;">
                <span class="dark-mode-icon">ğŸŒ™</span>
            </button>
        </div>

        <div class="header">
            <h1>ğŸ“¦ ã‚³ãƒ³ãƒ†ãƒŠç©è¼‰ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œç‰ˆï¼‰</h1>
            <p>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„ãƒ»ãƒã‚°ä¿®æ­£ãƒ»é«˜ã•å·®èª¿æ•´æ©Ÿèƒ½ã‚’å®Ÿè£…ã—ãŸæ”¹è‰¯ãƒãƒ¼ã‚¸ãƒ§ãƒ³</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="form-group">
                    <label for="containerType">ã‚³ãƒ³ãƒ†ãƒŠã‚¿ã‚¤ãƒ—</label>
                    <select id="containerType" class="form-select">
                        <option value="20ft">20ftã‚³ãƒ³ãƒ†ãƒŠ (5.898m Ã— 2.352m å†…å¯¸)</option>
                        <option value="40ft">40ftã‚³ãƒ³ãƒ†ãƒŠ (12.032m Ã— 2.350m å†…å¯¸)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>ãƒ‘ãƒ¬ãƒƒãƒˆå¯¸æ³• (cm)</label>
                    <div class="dimensions-grid">
                        <input id="palletLength" max="300" min="1" placeholder="é•·ã•" type="number" class="form-input"/>
                        <input id="palletWidth" max="300" min="1" placeholder="å¹…" type="number" class="form-input"/>
                    </div>
                    <div class="preset-pallets">
                        <button class="preset-btn" data-length="120" data-width="100" type="button">
                            EUR<br/>(120Ã—100)
                        </button>
                        <button class="preset-btn" data-length="120" data-width="80" type="button">
                            EUR2<br/>(120Ã—80)
                        </button>
                        <button class="preset-btn" data-length="122" data-width="102" type="button">
                            US<br/>(122Ã—102)
                        </button>
                        <button class="preset-btn" data-length="110" data-width="110" type="button">
                            æ­£æ–¹å½¢<br/>(110Ã—110)
                        </button>
                        <button class="preset-btn" data-length="100" data-width="125" type="button">
                            ã‚«ã‚¹ã‚¿ãƒ <br/>(100Ã—125)
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="palletQty">æ•°é‡</label>
                    <input id="palletQty" max="100" min="1" placeholder="ãƒ‘ãƒ¬ãƒƒãƒˆæ•°" type="number" value="1" class="form-input"/>
                </div>

                <!-- é«˜ã•èª¿æ•´è¨­å®š -->
                <div class="height-adjustment-setting">
                    <h4>ğŸ“ é«˜ã•èª¿æ•´è¨­å®š</h4>
                    <div class="height-adjustment-controls">
                        <div class="height-adjustment-input">
                            <label for="heightAdjustment">é«˜ã•èª¿æ•´å€¤:</label>
                            <input id="heightAdjustment" type="number" min="0" max="50" step="0.5" value="0" class="form-input"/>
                            <span class="height-adjustment-unit">cm</span>
                        </div>
                        <div class="height-adjustment-info">
                            ğŸ’¡ åŒã˜å±¤å†…ã§ã®ãƒ‘ãƒ¬ãƒƒãƒˆé«˜ã•ã‚’æƒãˆã‚‹ãŸã‚ã®åº•ä¸Šã’èª¿æ•´å€¤ã§ã™ã€‚<br/>
                            ãƒ‘ãƒ¬ãƒƒãƒˆä¸‹éƒ¨ã«æŒ¿å…¥ã™ã‚‹ã‚¹ãƒšãƒ¼ã‚µãƒ¼ã‚„ã‚¯ãƒƒã‚·ãƒ§ãƒ³æã®åšã•ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="clearanceValue">ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹ (cm)</label>
                    <input id="clearanceValue" max="50" min="0" placeholder="ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹" step="0.1" type="number" value="0" class="form-input"/>
                    <small style="color: #6c757d; font-size: 12px; margin-top: 5px; display: block;">
                        ãƒ‘ãƒ¬ãƒƒãƒˆé–“ã®æœ€å°é–“éš”ã‚’è¨­å®šï¼ˆ0.1cmåˆ»ã¿èª¿æ•´å¯èƒ½ï¼‰<br/>
                        <strong>â€»è¨ˆç®—æ™‚ã«é©ç”¨ã•ã‚Œã¾ã™ï¼ˆ0=éš™é–“ãªã—é…ç½®ã§æœ€å¤§ç©è¼‰ï¼‰</strong>
                    </small>
                </div>

                <button class="add-pallet-btn" id="addPalletBtn" type="button">â• ãƒ‘ãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ </button>

                <div class="form-group">
                    <label>ãƒ‘ãƒ¬ãƒƒãƒˆãƒªã‚¹ãƒˆ</label>
                    <div class="pallet-list" id="palletList">
                        <p style="text-align: center; color: #6c757d; font-style: italic;">ãƒ‘ãƒ¬ãƒƒãƒˆãŒã¾ã è¿½åŠ ã•ã‚Œã¦ã„ã¾ã›ã‚“</p>
                    </div>
                </div>

                <button class="test-btn" id="testBtn" type="button">ğŸ§ª ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹å®Ÿè¡Œ</button>
                <button class="calculate-btn" id="calculateBtn" type="button">ğŸ”„ ç©è¼‰ãƒ—ãƒ©ãƒ³ã‚’è¨ˆç®—</button>
                <button class="export-btn" id="exportBtn" style="display: none;" type="button">ğŸ–¼ï¸ é…ç½®å›³ã‚’ç”»åƒã§ä¿å­˜</button>
            </div>

            <div class="visualization">
                <div class="error-message" id="errorMessage"></div>
                <div class="success-message" id="successMessage"></div>
                <div class="container-info" id="containerInfo">
                    ã‚³ãƒ³ãƒ†ãƒŠã‚¿ã‚¤ãƒ—ã‚’é¸æŠã—ã¦ãƒ‘ãƒ¬ãƒƒãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„
                </div>

                <div class="loading-animation" id="loadingAnimation">
                    <div class="spinner"></div>
                    <p>æœ€é©ãªç©è¼‰ãƒ—ãƒ©ãƒ³ã‚’è¨ˆç®—ä¸­...</p>
                </div>

                <div class="manual-instructions" id="manualInstructions" style="display: none;">
                    <h4>ğŸ“‹ ãƒãƒ‹ãƒ¥ã‚¢ãƒ«èª¿æ•´ã‚¬ã‚¤ãƒ‰</h4>
                    <ul>
                        <li>ğŸ–±ï¸ ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è‡ªç”±ã«ä½ç½®èª¿æ•´</li>
                        <li>â†» å›è»¢ãƒœã‚¿ãƒ³ã§å‘ãã‚’å¤‰æ›´</li>
                        <li>ğŸ“ é«˜ã•ãƒœã‚¿ãƒ³ã§å€‹åˆ¥ã®é«˜ã•èª¿æ•´</li>
                        <li>ğŸ—‘ï¸ å‰Šé™¤ãƒœã‚¿ãƒ³ã§ä¸è¦ãªãƒ‘ãƒ¬ãƒƒãƒˆã‚’é™¤å»</li>
                        <li>ğŸ”´ èµ¤ã„æ ç·šã¯ã‚³ãƒ³ãƒ†ãƒŠæ å¤–é…ç½®ã‚’ç¤ºã—ã¾ã™</li>
                        <li>ğŸ”µ é’ã„æ ç·šã¯é«˜ã•èª¿æ•´ã•ã‚ŒãŸãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç¤ºã—ã¾ã™</li>
                        <li>ğŸ“¦ ã‚°ãƒ¬ãƒ¼æ ç·šã¯ä¸‹å´é…ç½®ï¼ˆè‡ªå‹•ã§é…ç½®ã•ã‚ŒãŸã‚‚ã®ï¼‰</li>
                        <li>ğŸ”„ åŒã˜ã‚µã‚¤ã‚ºã§ã‚‚å€‹åˆ¥ã«å‘ãã‚„é«˜ã•ã‚’å¤‰æ›´å¯èƒ½</li>
                        <li>âœ¨ å¢ƒç•Œåˆ¶é™ãªã—ï¼šã‚³ãƒ³ãƒ†ãƒŠæ ç·šã´ã£ãŸã‚Šã¾ã§é…ç½®å¯èƒ½</li>
                    </ul>
                </div>

                <div class="legend" id="legend" style="display: none;"></div>
                <div class="unloaded-summary" id="unloadedSummary" style="display: none;"></div>

                <div class="container-view">
                    <div class="work-area">
                        <div class="container-floor" id="containerFloor"></div>
                    </div>
                </div>

                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-card">
                        <div class="stat-value" id="inputPallets">0</div>
                        <div class="stat-label">å…¥åŠ›ãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="visiblePallets">0</div>
                        <div class="stat-label">è¡¨ç¤ºãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="loadedPallets">0</div>
                        <div class="stat-label">æ å†…ãƒ‘ãƒ¬ãƒƒãƒˆæ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="loadingRate">0%</div>
                        <div class="stat-label">ç©è¼‰ç‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="efficiency">0%</div>
                        <div class="stat-label">åºŠé¢åŠ¹ç‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="remainingArea">0mÂ²</div>
                        <div class="stat-label">æ®‹ã‚ŠåºŠé¢ç©</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalHeightAdjustment">0cm</div>
                        <div class="stat-label">ç·é«˜ã•èª¿æ•´</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ç®¡ç†
        let isDarkMode = false;

        function toggleDarkMode() {
            isDarkMode = !isDarkMode;
            document.body.classList.toggle('dark-mode', isDarkMode);
            updateDarkModeIcon();
        }

        function updateDarkModeIcon() {
            const icon = document.querySelector('.dark-mode-icon');
            if (icon) {
                icon.textContent = isDarkMode ? 'â˜€ï¸' : 'ğŸŒ™';
            }
        }

        function initializeDarkMode() {
            document.body.classList.remove('dark-mode');
            isDarkMode = false;
            updateDarkModeIcon();
        }

        // å®šæ•°ã®ä¸€å…ƒç®¡ç†
        const CONSTANTS = {
            CONTAINER_OFFSET_X: 30,
            CONTAINER_OFFSET_Y: 30,
            CONTAINER_DISPLAY_WIDTH: 800,
            CONTAINER_DISPLAY_HEIGHT: 300,
            MIN_DRAG_MARGIN: 10,
            EPSILON: 0.01,
            ANIMATION_DELAY: 500
        };

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let pallets = [];
        let allPalletsGenerated = [];
        let renderConfig = {
            scale: 1,
            containerOffset: { x: CONSTANTS.CONTAINER_OFFSET_X, y: CONSTANTS.CONTAINER_OFFSET_Y },
            containerBounds: null
        };

        const containers = {
            '20ft': { length: 589.8, width: 235.2 },
            '40ft': { length: 1203.2, width: 235.0 }
        };

        // DOMè¦ç´ ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        const elements = {
            containerType: document.getElementById('containerType'),
            palletLength: document.getElementById('palletLength'),
            palletWidth: document.getElementById('palletWidth'),
            palletQty: document.getElementById('palletQty'),
            heightAdjustment: document.getElementById('heightAdjustment'),
            clearanceValue: document.getElementById('clearanceValue'),
            addPalletBtn: document.getElementById('addPalletBtn'),
            calculateBtn: document.getElementById('calculateBtn'),
            testBtn: document.getElementById('testBtn'),
            exportBtn: document.getElementById('exportBtn'),
            palletList: document.getElementById('palletList'),
            containerInfo: document.getElementById('containerInfo'),
            loadingAnimation: document.getElementById('loadingAnimation'),
            manualInstructions: document.getElementById('manualInstructions'),
            legend: document.getElementById('legend'),
            unloadedSummary: document.getElementById('unloadedSummary'),
            containerFloor: document.getElementById('containerFloor'),
            stats: document.getElementById('stats'),
            errorMessage: document.getElementById('errorMessage'),
            successMessage: document.getElementById('successMessage')
        };

        // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
        const utils = {
            getCurrentClearance: () => parseFloat(elements.clearanceValue.value) || 0,
            getCurrentHeightAdjustment: () => parseFloat(elements.heightAdjustment.value) || 0,
            getRandomColor: () => {
                const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            showError: (message) => {
                elements.errorMessage.textContent = message;
                elements.errorMessage.style.display = 'block';
                setTimeout(() => elements.errorMessage.style.display = 'none', 5000);
            },
            showSuccess: (message) => {
                elements.successMessage.textContent = message;
                elements.successMessage.style.display = 'block';
                setTimeout(() => elements.successMessage.style.display = 'none', 5000);
            },
            adjustColor: (color, amount) => {
                return '#' + color.replace(/^#/, '').replace(/../g, value => 
                    ('0' + Math.min(255, Math.max(0, parseInt(value, 16) + amount)).toString(16)).substr(-2)
                );
            },
            calculateScale: (container) => {
                const scaleX = CONSTANTS.CONTAINER_DISPLAY_WIDTH / container.length;
                const scaleY = CONSTANTS.CONTAINER_DISPLAY_HEIGHT / container.width;
                return Math.min(scaleX, scaleY);
            }
        };

        // ãƒ‘ãƒ¬ãƒƒãƒˆç®¡ç†
        const palletManager = {
            add: function() {
                const length = parseInt(elements.palletLength.value);
                const width = parseInt(elements.palletWidth.value);
                const qty = parseInt(elements.palletQty.value);
                const heightAdjustment = utils.getCurrentHeightAdjustment();
                
                if (!this.validate(length, width, qty)) return;
                
                pallets.push({
                    id: Date.now(),
                    length,
                    width,
                    qty,
                    heightAdjustment,
                    color: utils.getRandomColor()
                });
                
                updatePalletList();
                updateContainerInfo();
                clearInputs();
                clearResults();
            },
            
            validate: (length, width, qty) => {
                if (!length || !width || !qty || length <= 0 || width <= 0 || qty <= 0) {
                    utils.showError('æœ‰åŠ¹ãªãƒ‘ãƒ¬ãƒƒãƒˆå¯¸æ³•ã¨æ•°é‡ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                    return false;
                }
                if (length > 300 || width > 300) {
                    utils.showError('ãƒ‘ãƒ¬ãƒƒãƒˆã‚µã‚¤ã‚ºã¯300cmä»¥ä¸‹ã«ã—ã¦ãã ã•ã„');
                    return false;
                }
                if (qty > 100) {
                    utils.showError('ãƒ‘ãƒ¬ãƒƒãƒˆæ•°é‡ã¯100å€‹ä»¥ä¸‹ã«ã—ã¦ãã ã•ã„');
                    return false;
                }
                return true;
            },
            
            remove: (id) => {
                pallets = pallets.filter(p => p.id !== id);
                updatePalletList();
                updateContainerInfo();
                clearResults();
            }
        };

        // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
        function runTestCase() {
            pallets = [];
            allPalletsGenerated = [];
            elements.containerType.value = '40ft';
            elements.clearanceValue.value = '0';
            elements.heightAdjustment.value = '2.5';
            
            const testData = [
                { l: 110, w: 110, q: 12, h: 2.5, c: '#f39c12' },  // é»„è‰²
                { l: 100, w: 125, q: 8, h: 1.0, c: '#3498db' }    // é’è‰²
            ];
            
            testData.forEach((p, i) => pallets.push({
                id: Date.now() + i,
                length: p.l,
                width: p.w,
                qty: p.q,
                heightAdjustment: p.h,
                color: p.c
            }));
            
            updatePalletList();
            updateContainerInfo();
            clearResults();
            utils.showSuccess('ğŸ¯ é«˜ã•èª¿æ•´ãƒ†ã‚¹ãƒˆ: 110Ã—110 (+2.5cm) + 100Ã—125 (+1.0cm)');
        }

        // UIæ›´æ–°é–¢æ•°
        function updatePalletList() {
            elements.palletList.innerHTML = '';
            
            if (pallets.length === 0) {
                elements.palletList.innerHTML = '<p style="text-align:center;color:#6c757d;font-style:italic;">ãƒ‘ãƒ¬ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }
            
            pallets.forEach(p => {
                const item = document.createElement('div');
                item.className = 'pallet-item';
                const heightInfo = p.heightAdjustment > 0 ? ` +${p.heightAdjustment}cm` : '';
                item.innerHTML = `<span>${p.length}Ã—${p.width}cm (${p.qty}å€‹)${heightInfo}</span><button class="remove-btn">âœ•</button>`;
                item.querySelector('.remove-btn').addEventListener('click', () => palletManager.remove(p.id));
                elements.palletList.appendChild(item);
            });
        }

        function updateContainerInfo() {
            const container = containers[elements.containerType.value];
            const heightAdjustment = utils.getCurrentHeightAdjustment();
            const heightInfo = heightAdjustment > 0 ? ` | é«˜ã•èª¿æ•´: ${heightAdjustment}cm` : '';
            elements.containerInfo.innerHTML = `${elements.containerType.value}å†…å¯¸: ${(container.length/100).toFixed(3)}mÃ—${(container.width/100).toFixed(3)}m <small>ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹: ${utils.getCurrentClearance()}cm${heightInfo}</small>`;
        }

        function clearInputs() {
            elements.palletLength.value = '';
            elements.palletWidth.value = '';
            elements.palletQty.value = '1';
        }

        function clearResults() {
            allPalletsGenerated = [];
            const workArea = elements.containerFloor.parentElement;
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
            const container = containers[elements.containerType.value];
            renderConfig.scale = utils.calculateScale(container);
            
            elements.containerFloor.style.width = `${container.length * renderConfig.scale}px`;
            elements.containerFloor.style.height = `${container.width * renderConfig.scale}px`;
            elements.containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            elements.containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            ['stats', 'legend', 'unloadedSummary', 'exportBtn', 'manualInstructions'].forEach(id => {
                elements[id].style.display = 'none';
            });
        }

        // é…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ é–¢é€£
        function canPlace2D(x, y, length, width, placed, clearance, container = null) {
            const rect1 = { x, y, length, width };
            const cont = container || containers[elements.containerType.value];
            
            // å¢ƒç•Œãƒã‚§ãƒƒã‚¯
            if (x < 0 || y < 0 || x + length > cont.length || y + width > cont.width) {
                return false;
            }
            
            // è¡çªãƒã‚§ãƒƒã‚¯
            return !placed.some(rect2 => rectanglesOverlapWithClearance(rect1, rect2, clearance));
        }

        function rectanglesOverlapWithClearance(r1, r2, clearance) {
            return !(
                r1.x + r1.length + clearance <= r2.x + CONSTANTS.EPSILON ||
                r2.x + r2.length + clearance <= r1.x + CONSTANTS.EPSILON ||
                r1.y + r1.width + clearance <= r2.y + CONSTANTS.EPSILON ||
                r2.y + r2.width + clearance <= r1.y + CONSTANTS.EPSILON
            );
        }

        function calculateLoading() {
            if (pallets.length === 0) {
                return utils.showError('å°‘ãªãã¨ã‚‚1ã¤ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ã—ã¦ãã ã•ã„');
            }
            
            const container = containers[elements.containerType.value];
            const clearance = utils.getCurrentClearance();
            elements.loadingAnimation.style.display = 'block';
            elements.exportBtn.style.display = 'none';

            setTimeout(() => {
                allPalletsGenerated = [];
                
                // å…¨ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆ
                pallets.forEach(pt => {
                    for (let i = 0; i < pt.qty; i++) {
                        allPalletsGenerated.push({
                            id: pt.id,
                            instance: i,
                            length: pt.length,
                            width: pt.width,
                            heightAdjustment: pt.heightAdjustment,
                            color: pt.color,
                            placed: false,
                            deleted: false,
                            x: 0,
                            y: 0,
                            finalLength: pt.length,
                            finalWidth: pt.width,
                            rotated: false,
                            individualHeightAdjustment: pt.heightAdjustment // å€‹åˆ¥èª¿æ•´ç”¨
                        });
                    }
                });
                
                console.log(`ç”Ÿæˆã•ã‚ŒãŸãƒ‘ãƒ¬ãƒƒãƒˆæ•°: ${allPalletsGenerated.length}`);
                console.log(`ã‚³ãƒ³ãƒ†ãƒŠã‚µã‚¤ã‚º: ${container.length}cm Ã— ${container.width}cm`);
                console.log(`ã‚¯ãƒªã‚¢ãƒ©ãƒ³ã‚¹: ${clearance}cm`);
                
                // è‡ªå‹•é…ç½®
                packPallets2D(allPalletsGenerated.filter(p => !p.deleted), container, clearance);
                
                const placedCount = allPalletsGenerated.filter(p => p.placed).length;
                const rotatedCount = allPalletsGenerated.filter(p => p.placed && p.rotated).length;
                const heightAdjustedCount = allPalletsGenerated.filter(p => p.individualHeightAdjustment > 0).length;
                
                elements.loadingAnimation.style.display = 'none';
                elements.exportBtn.style.display = 'block';
                elements.manualInstructions.style.display = 'block';
                
                renderAllPallets(container);
                updateStats(container);
                updateLegend();

                let message = '';
                if (placedCount === allPalletsGenerated.length) {
                    message = `ğŸ‰ å…¨${allPalletsGenerated.length}å€‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆãŒè‡ªå‹•é…ç½®ã•ã‚Œã¾ã—ãŸï¼`;
                } else if (placedCount > 0) {
                    message = `âš¡ ${placedCount}/${allPalletsGenerated.length}å€‹ã‚’è‡ªå‹•é…ç½®ã€‚æ®‹ã‚Šã¯ãƒãƒ‹ãƒ¥ã‚¢ãƒ«èª¿æ•´ã—ã¦ãã ã•ã„ã€‚`;
                } else {
                    message = `ğŸ“¦ ${allPalletsGenerated.length}å€‹ã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã—ã¾ã—ãŸã€‚ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã§é…ç½®ã—ã¦ãã ã•ã„ã€‚`;
                }
                
                if (rotatedCount > 0) message += ` (å›è»¢: ${rotatedCount}å€‹)`;
                if (heightAdjustedCount > 0) message += ` (é«˜ã•èª¿æ•´: ${heightAdjustedCount}å€‹)`;
                
                utils.showSuccess(message);
            }, CONSTANTS.ANIMATION_DELAY);
        }

        // ç°¡ç•¥åŒ–ã•ã‚ŒãŸé…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        function packPallets2D(palletsToPlace, container, clearance) {
            const placed = [];
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚¿ã‚¤ãƒ—ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groups = {};
            palletsToPlace.forEach(pallet => {
                const key = `${pallet.length}x${pallet.width}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(pallet);
            });
            
            console.log(`ã‚°ãƒ«ãƒ¼ãƒ—æ•°: ${Object.keys(groups).length}`);
            Object.entries(groups).forEach(([key, pallets]) => {
                console.log(`  ${key}: ${pallets.length}å€‹`);
            });
            
            // 100Ã—125ãƒ‘ãƒ¬ãƒƒãƒˆã®ç‰¹æ®Šé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦è¡Œ
            if (groups['100x125'] && groups['100x125'].length >= 8) {
                const specialPlaced = trySpecialPattern100x125(groups['100x125'], container, clearance);
                if (specialPlaced.length > 0) {
                    console.log(`100Ã—125ç‰¹æ®Šãƒ‘ã‚¿ãƒ¼ãƒ³ã§ ${specialPlaced.length} å€‹é…ç½®æˆåŠŸ`);
                    specialPlaced.forEach(p => {
                        const original = allPalletsGenerated.find(pallet => 
                            pallet.id === p.id && pallet.instance === p.instance
                        );
                        if (original) {
                            original.placed = true;
                            original.x = p.x;
                            original.y = p.y;
                            original.finalLength = p.finalLength;
                            original.finalWidth = p.finalWidth;
                            original.rotated = p.rotated;
                        }
                        placed.push({
                            x: p.x,
                            y: p.y,
                            length: p.finalLength,
                            width: p.finalWidth
                        });
                    });
                }
            }
            
            // 110Ã—110ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚°ãƒªãƒƒãƒ‰é…ç½®
            if (groups['110x110']) {
                const gridPlaced = placeGridPattern(groups['110x110'], container, clearance, placed);
                gridPlaced.forEach(p => {
                    const original = allPalletsGenerated.find(pallet => 
                        pallet.id === p.id && pallet.instance === p.instance
                    );
                    if (original) {
                        original.placed = true;
                        original.x = p.x;
                        original.y = p.y;
                        original.finalLength = p.finalLength;
                        original.finalWidth = p.finalWidth;
                        original.rotated = p.rotated;
                    }
                    placed.push({
                        x: p.x,
                        y: p.y,
                        length: p.finalLength,
                        width: p.finalWidth
                    });
                });
            }
            
            // æ®‹ã‚Šã®ãƒ‘ãƒ¬ãƒƒãƒˆã‚’é€šå¸¸é…ç½®
            const remainingPallets = palletsToPlace.filter(p => !p.placed);
            console.log(`æ®‹ã‚Šãƒ‘ãƒ¬ãƒƒãƒˆæ•°: ${remainingPallets.length}`);
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ã‚µã‚¤ã‚ºã§ã‚½ãƒ¼ãƒˆï¼ˆå¤§ãã„ã‚‚ã®ã‹ã‚‰ï¼‰
            remainingPallets.sort((a, b) => (b.length * b.width) - (a.length * a.width));
            
            remainingPallets.forEach(pallet => {
                let bestPosition = null;
                let bestScore = Infinity;
                let bestRotated = false;
                
                // é€šå¸¸é…ç½®ã¨å›è»¢é…ç½®ã®ä¸¡æ–¹ã‚’è©¦è¡Œ
                const orientations = pallet.length !== pallet.width ?
                    [[pallet.length, pallet.width, false], [pallet.width, pallet.length, true]] :
                    [[pallet.length, pallet.width, false]];
                
                orientations.forEach(([length, width, rotated]) => {
                    // ã‚°ãƒªãƒƒãƒ‰ãƒ™ãƒ¼ã‚¹ã§é…ç½®ä½ç½®ã‚’æ¢ç´¢
                    for (let y = 0; y <= container.width - width; y += 5) {
                        for (let x = 0; x <= container.length - length; x += 5) {
                            if (canPlace2D(x, y, length, width, placed, clearance)) {
                                // å·¦ä¸‹ã‚’å„ªå…ˆã™ã‚‹ã‚¹ã‚³ã‚¢è¨ˆç®—
                                const score = x + y * 2;
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPosition = { x, y };
                                    bestRotated = rotated;
                                }
                            }
                        }
                    }
                });
                
                if (bestPosition) {
                    pallet.placed = true;
                    pallet.x = bestPosition.x;
                    pallet.y = bestPosition.y;
                    pallet.rotated = bestRotated;
                    
                    if (bestRotated) {
                        pallet.finalLength = pallet.width;
                        pallet.finalWidth = pallet.length;
                    } else {
                        pallet.finalLength = pallet.length;
                        pallet.finalWidth = pallet.width;
                    }
                    
                    placed.push({
                        x: pallet.x,
                        y: pallet.y,
                        length: pallet.finalLength,
                        width: pallet.finalWidth
                    });
                }
            });
            
            console.log(`é€šå¸¸é…ç½®ã§è¿½åŠ é…ç½®: ${remainingPallets.filter(p => p.placed).length}å€‹`);
            
            // æœªé…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆã®æ•´åˆ—
            const unplaced = allPalletsGenerated.filter(p => !p.placed && !p.deleted);
            if (unplaced.length > 0) {
                console.log(`æœªé…ç½®ãƒ‘ãƒ¬ãƒƒãƒˆ: ${unplaced.length}å€‹`);
                let offsetX = 0;
                let offsetY = container.width + 30;
                let currentRowMaxHeight = 0;
                
                unplaced.forEach(pallet => {
                    if (offsetX + pallet.finalLength > container.length) {
                        offsetX = 0;
                        offsetY += currentRowMaxHeight + 10;
                        currentRowMaxHeight = 0;
                    }
                    
                    pallet.x = offsetX;
                    pallet.y = offsetY;
                    
                    currentRowMaxHeight = Math.max(currentRowMaxHeight, pallet.finalWidth);
                    offsetX += pallet.finalLength + 10;
                });
            }
        }

        // 100Ã—125ãƒ‘ãƒ¬ãƒƒãƒˆã®ç‰¹æ®Šé…ç½®ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        function trySpecialPattern100x125(pallets, container, clearance) {
            const placedPallets = [];
            const areaPlaced = [];
            
            const pattern = [
                { row: 0, col: 0, rotated: true },
                { row: 0, col: 1, rotated: false },
                { row: 0, col: 2, rotated: true },
                { row: 0, col: 3, rotated: false },
                { row: 1, col: 0, rotated: false },
                { row: 1, col: 1, rotated: true },
                { row: 1, col: 2, rotated: false },
                { row: 1, col: 3, rotated: true }
            ];
            
            let palletIndex = 0;
            const startX = 0;
            const startY = 0;
            
            pattern.forEach((pos, index) => {
                if (palletIndex >= pallets.length) return;
                
                const pallet = pallets[palletIndex];
                let x, y, length, width;
                
                if (pos.row === 0) {
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 125 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 125 + 100 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 125 + 100 + 125 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY;
                } else {
                    if (pos.col === 0) {
                        x = startX;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 1) {
                        x = startX + 100 + clearance;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else if (pos.col === 2) {
                        x = startX + 100 + 125 + clearance * 2;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    } else {
                        x = startX + 100 + 125 + 100 + clearance * 3;
                        length = pos.rotated ? 125 : 100;
                        width = pos.rotated ? 100 : 125;
                    }
                    y = startY + 125 + clearance;
                }
                
                if (x + length <= container.length && y + width <= container.width &&
                    canPlace2D(x, y, length, width, areaPlaced, 0)) {
                    
                    placedPallets.push({
                        ...pallet,
                        x: x,
                        y: y,
                        finalLength: length,
                        finalWidth: width,
                        rotated: pos.rotated,
                        placed: true
                    });
                    
                    areaPlaced.push({
                        x: x,
                        y: y,
                        length: length,
                        width: width
                    });
                    
                    palletIndex++;
                    console.log(`100Ã—125 é…ç½®: ${pos.rotated ? 'æ¨ª' : 'ç¸¦'}å‘ã at (${x}, ${y})`);
                }
            });
            
            return placedPallets;
        }

        // ã‚°ãƒªãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³é…ç½®ï¼ˆ110Ã—110ç”¨ã€é«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        function placeGridPattern(pallets, container, clearance, alreadyPlaced) {
            const placedPallets = [];
            const length = 110;
            const width = 110;
            
            const startX = 500 + clearance;
            const startY = 0;
            
            const cols = Math.floor((container.length - startX) / (length + clearance));
            const rows = Math.floor(container.width / (width + clearance));
            
            let palletIndex = 0;
            
            for (let row = 0; row < rows && palletIndex < pallets.length; row++) {
                for (let col = 0; col < cols && palletIndex < pallets.length; col++) {
                    const x = startX + col * (length + clearance);
                    const y = startY + row * (width + clearance);
                    
                    if (canPlace2D(x, y, length, width, alreadyPlaced, clearance)) {
                        const pallet = pallets[palletIndex++];
                        placedPallets.push({
                            ...pallet,
                            x: x,
                            y: y,
                            finalLength: length,
                            finalWidth: width,
                            rotated: false,
                            placed: true
                        });
                    }
                }
            }
            
            console.log(`110Ã—110 ã‚°ãƒªãƒƒãƒ‰é…ç½®: ${cols}åˆ—Ã—${rows}è¡Œã§${placedPallets.length}å€‹é…ç½®`);
            
            return placedPallets;
        }

        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        function renderAllPallets(container) {
            const containerFloor = elements.containerFloor;
            const workArea = containerFloor.parentElement;
            
            renderConfig.scale = utils.calculateScale(container);
            const actualDisplayWidth = container.length * renderConfig.scale;
            const actualDisplayHeight = container.width * renderConfig.scale;
            
            containerFloor.style.width = `${actualDisplayWidth}px`;
            containerFloor.style.height = `${actualDisplayHeight}px`;
            containerFloor.style.position = 'absolute';
            containerFloor.style.left = `${CONSTANTS.CONTAINER_OFFSET_X}px`;
            containerFloor.style.top = `${CONSTANTS.CONTAINER_OFFSET_Y}px`;
            
            const unplacedPallets = allPalletsGenerated.filter(p => !p.deleted && !p.placed);
            let maxBottomY = actualDisplayHeight + CONSTANTS.CONTAINER_OFFSET_Y;
            
            if (unplacedPallets.length > 0) {
                const bottomMostY = Math.max(...unplacedPallets.map(p => 
                    ((p.y + p.finalWidth) * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y
                ));
                maxBottomY = Math.max(maxBottomY, bottomMostY + 50);
            }
            
            workArea.style.width = `${actualDisplayWidth + CONSTANTS.CONTAINER_OFFSET_X + 50}px`;
            workArea.style.height = `${Math.max(maxBottomY, 400 + CONSTANTS.CONTAINER_OFFSET_Y)}px`;
            workArea.style.position = 'relative';
            
            workArea.querySelectorAll('.pallet-2d').forEach(el => el.remove());
            
            // ãƒ‘ãƒ¬ãƒƒãƒˆã‚’æç”»ï¼ˆé«˜ã•èª¿æ•´è¡¨ç¤ºå¯¾å¿œï¼‰
            allPalletsGenerated.forEach(pallet => {
                if (pallet.deleted) return;
                
                const el = document.createElement('div');
                el.className = 'pallet-2d';
                el.dataset.palletId = pallet.id;
                el.dataset.instance = pallet.instance;
                
                const palletWidth = pallet.finalLength * renderConfig.scale;
                const palletHeight = pallet.finalWidth * renderConfig.scale;
                const palletLeft = (pallet.x * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_X;
                const palletTop = (pallet.y * renderConfig.scale) + CONSTANTS.CONTAINER_OFFSET_Y;
                
                Object.assign(el.style, {
                    width: `${palletWidth}px`,
                    height: `${palletHeight}px`,
                    left: `${palletLeft}px`,
                    top: `${palletTop}px`,
                    background: pallet.color,
                    position: 'absolute'
                });
                
                if (pallet.rotated) {
                    el.style.background = `repeating-linear-gradient(45deg, ${pallet.color}, ${pallet.color} 10px, ${utils.adjustColor(pallet.color, -20)} 10px, ${utils.adjustColor(pallet.color, -20)} 20px)`;
                }
                
                // çŠ¶æ…‹ã«å¿œã˜ãŸã‚¯ãƒ©ã‚¹ä»˜ä¸
                const isOutside = isOutsideContainer(pallet, container);
                const isBottomPlaced = pallet.y > container.width;
                const hasHeightAdjustment = pallet.individualHeightAdjustment > 0;
                
                if (isBottomPlaced) {
                    el.classList.add('bottom-placed');
                } else if (isOutside) {
                    el.classList.add('outside-container');
                }
                
                if (hasHeightAdjustment) {
                    el.classList.add('height-adjusted');
                }
                
                const heightInfo = hasHeightAdjustment ? ` +${pallet.individualHeightAdjustment}cm` : '';
                const rotationInfo = pallet.rotated ? ' â†»' : '';
                
                el.innerHTML = `
                    <div class="pallet-label">${pallet.finalLength}Ã—${pallet.finalWidth}${rotationInfo}${heightInfo}</div>
                    <div class="pallet-controls">
                        <button class="rotate-btn" title="å›è»¢">â†»</button>
                        <button class="height-btn" title="é«˜ã•èª¿æ•´">ğŸ“</button>
                        <button class="delete-btn" title="å‰Šé™¤">âœ•</button>
                    </div>
                `;
                
                workArea.appendChild(el);
            });
            
            renderConfig.containerBounds = {
                left: CONSTANTS.CONTAINER_OFFSET_X,
                top: CONSTANTS.CONTAINER_OFFSET_Y,
                width: actualDisplayWidth,
                height: actualDisplayHeight
            };
            
            enableDragAndDropAndActions();
        }

        function isOutsideContainer(pallet, container) {
            return pallet.x < 0 || pallet.y < 0 ||
                   pallet.x + pallet.finalLength > container.length ||
                   pallet.y + pallet.finalWidth > container.width;
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—æ©Ÿèƒ½ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        let isDDListenerAttached = false;
        function enableDragAndDropAndActions() {
            const workArea = elements.containerFloor.parentElement;
            if (isDDListenerAttached) return;

            let activePalletEl = null;
            let initialMouseX, initialMouseY;

            workArea.addEventListener('mousedown', handleMouseDown);
            isDDListenerAttached = true;

            function handleMouseDown(e) {
                const target = e.target;
                if (target.classList.contains('rotate-btn')) {
                    e.stopPropagation();
                    rotatePallet(target.closest('.pallet-2d'));
                } else if (target.classList.contains('height-btn')) {
                    e.stopPropagation();
                    adjustPalletHeight(target.closest('.pallet-2d'));
                } else if (target.classList.contains('delete-btn')) {
                    e.stopPropagation();
                    deletePallet(target.closest('.pallet-2d'));
                } else {
                    const palletEl = target.classList.contains('pallet-2d') ? target : target.closest('.pallet-2d');
                    if (palletEl) {
                        dragStart(e, palletEl);
                    }
                }
            }

            function dragStart(e, palletEl) {
                e.preventDefault();
                activePalletEl = palletEl;
                activePalletEl.classList.add('dragging');
                
                const palletRect = activePalletEl.getBoundingClientRect();
                const workAreaRect = workArea.getBoundingClientRect();
                
                initialMouseX = e.clientX - palletRect.left;
                initialMouseY = e.clientY - palletRect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', dragEnd);
            }

            function drag(e) {
                if (!activePalletEl) return;
                e.preventDefault();
                
                const workAreaRect = workArea.getBoundingClientRect();
                let newLeft = e.clientX - workAreaRect.left - initialMouseX;
                let newTop = e.clientY - workAreaRect.top - initialMouseY;
                
                newLeft = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                          Math.min(newLeft, workArea.clientWidth - activePalletEl.clientWidth - CONSTANTS.MIN_DRAG_MARGIN));
                newTop = Math.max(CONSTANTS.MIN_DRAG_MARGIN, 
                         Math.min(newTop, workArea.clientHeight - activePalletEl.clientHeight - CONSTANTS.MIN_DRAG_MARGIN));
                
                activePalletEl.style.left = `${newLeft}px`;
                activePalletEl.style.top = `${newTop}px`;
                
                updatePalletStatus(activePalletEl);
            }

            function dragEnd() {
                if (!activePalletEl) return;
                activePalletEl.classList.remove('dragging');
                updatePalletModel(activePalletEl);
                updateStats(containers[elements.containerType.value]);
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', dragEnd);
                activePalletEl = null;
            }

            function rotatePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                [palletData.finalLength, palletData.finalWidth] = [palletData.finalWidth, palletData.finalLength];
                palletData.rotated = !palletData.rotated;

                const container = containers[elements.containerType.value];
                palletEl.style.width = `${palletData.finalLength * renderConfig.scale}px`;
                palletEl.style.height = `${palletData.finalWidth * renderConfig.scale}px`;
                
                const heightInfo = palletData.individualHeightAdjustment > 0 ? ` +${palletData.individualHeightAdjustment}cm` : '';
                const rotationInfo = palletData.rotated ? ' â†»' : '';
                palletEl.querySelector('.pallet-label').textContent = 
                    `${palletData.finalLength}Ã—${palletData.finalWidth}${rotationInfo}${heightInfo}`;
                
                if (palletData.rotated) {
                    palletEl.style.background = `repeating-linear-gradient(45deg, ${palletData.color}, ${palletData.color} 10px, ${utils.adjustColor(palletData.color, -20)} 10px, ${utils.adjustColor(palletData.color, -20)} 20px)`;
                } else {
                    palletEl.style.background = palletData.color;
                }

                if (palletEl.offsetLeft + palletEl.offsetWidth > workArea.clientWidth) {
                    palletEl.style.left = `${Math.max(0, workArea.clientWidth - palletEl.offsetWidth)}px`;
                }
                if (palletEl.offsetTop + palletEl.offsetHeight > workArea.clientHeight) {
                    palletEl.style.top = `${Math.max(0, workArea.clientHeight - palletEl.offsetHeight)}px`;
                }
                
                updatePalletModel(palletEl);
                updatePalletStatus(palletEl);
                updateStats(container);
            }

            function adjustPalletHeight(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                const currentHeight = palletData.individualHeightAdjustment || 0;
                const newHeight = prompt(
                    `ãƒ‘ãƒ¬ãƒƒãƒˆã®é«˜ã•èª¿æ•´å€¤ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ç¾åœ¨: ${currentHeight}cm)`, 
                    currentHeight
                );
                
                if (newHeight !== null && !isNaN(parseFloat(newHeight))) {
                    const heightValue = Math.max(0, Math.min(50, parseFloat(newHeight)));
                    palletData.individualHeightAdjustment = heightValue;
                    
                    // è¡¨ç¤ºæ›´æ–°
                    const heightInfo = heightValue > 0 ? ` +${heightValue}cm` : '';
                    const rotationInfo = palletData.rotated ? ' â†»' : '';
                    palletEl.querySelector('.pallet-label').textContent = 
                        `${palletData.finalLength}Ã—${palletData.finalWidth}${rotationInfo}${heightInfo}`;
                    
                    // ã‚¹ã‚¿ã‚¤ãƒ«æ›´æ–°
                    if (heightValue > 0) {
                        palletEl.classList.add('height-adjusted');
                    } else {
                        palletEl.classList.remove('height-adjusted');
                    }
                    
                    updateStats(containers[elements.containerType.value]);
                    utils.showSuccess(`ãƒ‘ãƒ¬ãƒƒãƒˆã®é«˜ã•èª¿æ•´ã‚’${heightValue}cmã«è¨­å®šã—ã¾ã—ãŸ`);
                }
            }

            function deletePallet(palletEl) {
                if (!palletEl) return;
                
                const palletData = allPalletsGenerated.find(p =>
                    p.id == palletEl.dataset.palletId && p.instance == palletEl.dataset.instance
                );
                if (!palletData) return;

                palletData.deleted = true;
                palletEl.remove();
                updateStats(containers[elements.containerType.value]);
                utils.showSuccess('ãƒ‘ãƒ¬ãƒƒãƒˆãŒå‰Šé™¤ã•ã‚Œã¾ã—ãŸ');
            }

            function updatePalletStatus(palletEl) {
                const container = containers[elements.containerType.value];
                const palletData = {
                    x: (parseFloat(palletEl.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (parseFloat(palletEl.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    finalLength: palletEl.clientWidth / renderConfig.scale,
                    finalWidth: palletEl.clientHeight / renderConfig.scale
                };

                const isOutside = isOutsideContainer(palletData, container);
                const hasCollision = checkCollision(palletEl);
                
                palletEl.classList.toggle('outside-container', isOutside);
                palletEl.classList.toggle('colliding', hasCollision);
            }

            function checkCollision(draggedEl) {
                const container = containers[elements.containerType.value];
                const clearance = utils.getCurrentClearance();
                
                const draggedRect = {
                    x: (draggedEl.offsetLeft - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale,
                    y: (draggedEl.offsetTop - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale,
                    length: draggedEl.clientWidth / renderConfig.scale,
                    width: draggedEl.clientHeight / renderConfig.scale
                };
                
                return allPalletsGenerated.some(p => {
                    if (p.deleted) return false;
                    const el = workArea.querySelector(`[data-pallet-id="${p.id}"][data-instance="${p.instance}"]`);
                    if (el === draggedEl) return false;
                    
                    return rectanglesOverlapWithClearance(
                        draggedRect,
                        { x: p.x, y: p.y, length: p.finalLength, width: p.finalWidth },
                        clearance
                    );
                });
            }

            function updatePalletModel(el) {
                const palletData = allPalletsGenerated.find(p =>
                    p.id == el.dataset.palletId && p.instance == el.dataset.instance
                );
                if (palletData) {
                    palletData.x = (parseFloat(el.style.left) - CONSTANTS.CONTAINER_OFFSET_X) / renderConfig.scale;
                    palletData.y = (parseFloat(el.style.top) - CONSTANTS.CONTAINER_OFFSET_Y) / renderConfig.scale;
                }
            }
        }

        // çµ±è¨ˆæ›´æ–°ï¼ˆé«˜ã•èª¿æ•´å¯¾å¿œï¼‰
        function updateStats(container) {
            const visiblePallets = allPalletsGenerated.filter(p => !p.deleted);
            const insidePallets = visiblePallets.filter(p => !isOutsideContainer(p, container));
            
            const containerArea = (container.length * container.width) / 10000;
            const usedArea = insidePallets.reduce((sum, p) => 
                sum + (p.finalLength * p.finalWidth) / 10000, 0
            );
            
            const totalInputPallets = pallets.reduce((sum, p) => sum + p.qty, 0);
            const totalHeightAdjustment = allPalletsGenerated.reduce((sum, p) => 
                sum + (p.individualHeightAdjustment || 0), 0
            );
            
            document.getElementById('inputPallets').textContent = totalInputPallets;
            document.getElementById('visiblePallets').textContent = visiblePallets.length;
            document.getElementById('loadedPallets').textContent = insidePallets.length;
            document.getElementById('loadingRate').textContent = 
                `${totalInputPallets > 0 ? Math.round((insidePallets.length / totalInputPallets) * 100) : 0}%`;
            document.getElementById('efficiency').textContent = 
                `${containerArea > 0 ? Math.round((usedArea / containerArea) * 100) : 0}%`;
            document.getElementById('remainingArea').textContent = `${(containerArea - usedArea).toFixed(2)}mÂ²`;
            document.getElementById('totalHeightAdjustment').textContent = `${totalHeightAdjustment.toFixed(1)}cm`;
            
            elements.stats.style.display = 'grid';
        }

        function updateLegend() {
            elements.legend.innerHTML = '';
            if (pallets.length === 0) {
                elements.legend.style.display = 'none';
                return;
            }
            
            pallets.forEach(p => {
                const heightInfo = p.heightAdjustment > 0 ? ` (+${p.heightAdjustment}cm)` : '';
                elements.legend.innerHTML += `
                    <div class="legend-item">
                        <div class="legend-color" style="background:${p.color};"></div>
                        <span>${p.length}Ã—${p.width}cm (${p.qty}å€‹)${heightInfo}</span>
                    </div>
                `;
            });
            elements.legend.style.display = 'flex';
        }

        // ç”»åƒã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportLayoutAsImage() {
            const vizArea = document.querySelector('.visualization');
            elements.exportBtn.style.visibility = 'hidden';
            utils.showSuccess('ğŸ–¼ï¸ ç”»åƒã‚’ç”Ÿæˆä¸­ã§ã™...');
            
            html2canvas(vizArea, { 
                scale: 2, 
                useCORS: true, 
                backgroundColor: '#ffffff' 
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = `container-loading-plan-${new Date().toISOString().slice(0,10)}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                elements.exportBtn.style.visibility = 'visible';
            }).catch(err => {
                console.error('Image export failed:', err);
                utils.showError('ç”»åƒã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                elements.exportBtn.style.visibility = 'visible';
            });
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è¨­å®š
        function setupEventListeners() {
            elements.addPalletBtn.addEventListener('click', () => palletManager.add());
            elements.calculateBtn.addEventListener('click', calculateLoading);
            elements.testBtn.addEventListener('click', runTestCase);
            elements.exportBtn.addEventListener('click', exportLayoutAsImage);
            elements.containerType.addEventListener('change', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.clearanceValue.addEventListener('input', () => {
                updateContainerInfo();
                clearResults();
            });
            elements.heightAdjustment.addEventListener('input', () => {
                updateContainerInfo();
            });
            
            [elements.palletLength, elements.palletWidth, elements.palletQty].forEach(input => {
                input.addEventListener('keypress', e => {
                    if (e.key === 'Enter') palletManager.add();
                });
            });
        }

        function setupPresetButtons() {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.palletLength.value = this.dataset.length;
                    elements.palletWidth.value = this.dataset.width;
                    elements.palletQty.focus();
                });
            });
        }

        // åˆæœŸåŒ–
        function init() {
            initializeDarkMode();
            setupPresetButtons();
            setupEventListeners();
            updateContainerInfo();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>